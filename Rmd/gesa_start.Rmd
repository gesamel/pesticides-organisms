---
title: "Untitled"
author: "Gesa Amelung"
date: "7 November 2017"
output:
  html_document: default
  pdf_document: default
---

## Setup

Load the following packages and load the data base access scipt:

```{r setup, echo=TRUE, message=FALSE}
## load packages
require(RPostgreSQL)
require(sf)
require(knitr)

## load access data
path = 'D:/Gesa/Dokumente/Ecotoxicology/RPC'
source(file.path(path, 'amelung_access.R'))

```

## Loading data

Query PostgresSQL data base: bfg_monitoring
Cannot load full psm_samples so far, maybe internet is too weak.. Set LIMIT 100

```{r load-PSM-data, echo=TRUE, message=FALSE}
drv = dbDriver("PostgreSQL")
con = dbConnect(drv, dbname = DBname, user = DBuser, host = DBhost, port = DBport, password = DBpassword)

psm_sites = dbGetQuery(con, "SELECT *
                             FROM views.psm_sites_2005
                       ")
psm_samples2 = dbGetQuery(con, "SELECT *
                               FROM views.psm_samples_2005 sam
                               JOIN phch.phch_variables var 
                              ON var.variable_id = sam.variable_id
                         WHERE var.psm_type = 'herbicide'
                         ORDER BY sam.sample_id
                         LIMIT 1000")


psm = dbGetQuery(con, "SELECT *
                               FROM views.psm_samples_2005 sam
                               
                         ORDER BY sam.sample_id
                         LIMIT 1000")

dbDisconnect(con)
dbUnloadDriver(drv)
```

```{r load-diatom-data, echo=TRUE, message=FALSE}
drv = dbDriver("PostgreSQL")
con = dbConnect(drv, dbname = DBname, user = DBuser, host = DBhost, port = DBport, password = DBpassword)

require(RPostgreSQL)
require(sf)
require(mapview)

dia_sites = dbGetQuery(con, "SELECT * FROM dia.dia_sites")
dia_sites_geo = st_read_db(con, query = "SELECT * FROM dia.dia_sites LIMIT 10")
dia_sam = dbGetQuery(con, "SELECT *
                       FROM dia.dia_samples
                       WHERE date > '2004-12-31'
                       ")
mapview(dia_sites_geo)

dbDisconnect(con)
dbUnloadDriver(drv)
```

Load physical-chemical data
```{r load-phch-data, echo=TRUE, message=FALSE}
drv = dbDriver("PostgreSQL")
con = dbConnect(drv, dbname = DBname, user = DBuser, host = DBhost, port = DBport, password = DBpassword)

# there are more sites than psm_sites (including only pesticides) though they aren't necessary for us.
phch_samples = dbGetQuery(con, "SELECT *
                                FROM phch.phch_samples sam
                                JOIN phch.phch_variables var ON var.variable_id = sam.variable_id
                                WHERE var.name IN ('Wassertemperatur', 'Sulfat');")

# 596477 observations

dbDisconnect(con)
dbUnloadDriver(drv)
```

## Question: How to compare diatom and psm sampling sites?
Where were samples taken at the same location?

Which column should I use to compare both datasets?
Random check if site_id exists in dia_sam.
Result: site_id is not the same in psm_samples and dia_sam.
Maybe labelling system is still the same, samples were just not always taken at same location?
```{r echo=TRUE, message=FALSE}
# Random site_id taken from psm_samples
dia_sam[dia_sam$site_id=="BW_10001",] #no result
dia_sam[dia_sam$site_id=="RP_10002",] #no results
# Random site_id taken from dia_samples as a cross-check if code is correct.
dia_sam[dia_sam$site_id=="BW_AI025.00",] #185 results

```
Is site_name, site_id and site_nr the same in psm_sites dataset? 
Find out by counting distinct occurence of them.
Result: site_id and site_name does not mean the same.
Site_id and site_nr might be approximately the same.
``` {r echo=TRUE, message=FALSE}
# Complete data set has to be queried before!!
psm_siteid_list <- unique(psm_sites$site_id)
nrow(as.data.frame(psm_siteid_list)) # 3116 different entries for site_id in psm_sites

psm_sitename_list <- unique(psm_sites$site_name)
nrow(as.data.frame(psm_sitename_list)) # 2746 different entries for site_name in psm_sites

psm_sitenr_list <- unique(psm_sites$site_nr)
nrow(as.data.frame(psm_sitenr_list)) # 3114 different entries for site_nr in psm_sites

```

Random check if site_nr in dia_sites and psm_sites are the same.
Result: site_nr in psm_sites and dia_sites are not the same.
Maybe labelling system is still the same, samples were just not always taken at same location?
Check the other way around. Are site_nr of dia_sites found in psm_sites?
Result: Positive. Dia samples were probably not taken at all psm sampling locations.
```{r echo=TRUE, message=FALSE}
# Random site_nr taken from psm_sites
dia_sites[dia_sites$site_nr=="CAC029",] # no results
dia_sites[dia_sites$site_nr=="21094",] # no results
dia_sites[dia_sites$site_nr=="CEN901",] # no results
# Random site_nr taken from dia_sites as a cross-check to see if code is correct.
dia_sites[dia_sites$site_nr=="CEZ016",] # 1 result

# Check the other way around. Are site_nr of dia_sites found in psm_sites? YES.
psm_sites[psm_sites$site_nr=="CEZ016",] # 1 result
dia_sites[dia_sites$site_nr=="CEZ016",] # 1 result
psm_sites[psm_sites$site_nr=="CKO317",] # 1 result
dia_sites[dia_sites$site_nr=="CKO317",] # 1 result
psm_sites[psm_sites$site_nr=="21081",] # 1 result
dia_sites[dia_sites$site_nr=="21081",] # no results
psm_sites[psm_sites$site_nr=="105703",] # 1 result
dia_sites[dia_sites$site_nr=="105703",] # 1 result


```

Random check if site_id in dia_sites and psm_sites are the same.
Result: NO. Only sometimes it works.
``` {r echo=TRUE, message=FALSE}
psm_sites[psm_sites$site_id=="BW_CEZ016",] # 1 result
dia_sites[dia_sites$site_id=="BW_CEZ016",] # no result
psm_sites[psm_sites$site_id=="BW_CKO317",] # 1 result
dia_sites[dia_sites$site_id=="BW_CKO317",] # no result
psm_sites[psm_sites$site_id=="BY_3390",] # 1 result
dia_sites[dia_sites$site_id=="BY_3390",] # 1 result


```
# Result
site_id cannot be used to connect psm_sites and dia_sites. Instead site_nr must be used
since attribut is found in both tables.


## Compare both sample datasets
Filter sites where diatom and herbicide data was measured in the same year.
``` {r compare-sample-datasets, echo=TRUE, message=FALSE}
# Join both sample data frames. Add a column identifying which source each row comes from.
dia_sam$table <- "dia"
psm_samples$table <- "psm"
dia_sam_bind <- dia_sam[,c("date", "site_id", "table")]
psm_sam_bind <- psm_samples[,c("date", "site_id", "table")]
samples_bind <- rbind(dia_sam_bind,psm_sam_bind) # combine both sample tables

```

Create data frames with samples only from 2005.
``` {r create-year-column, echo=TRUE, message=FALSE}
# Create year column from date column
dia_sam$year <- as.numeric(format(dia_sam$date,'%Y'))
psm_samples$year <- as.numeric(format(psm_samples$date,'%Y'))

# Create data frames with samples only from 2005
dia_sam_05 <- dia_sam[dia_sam$year=="2005",]
psm_sam_05 <- psm_samples[psm_samples$year=="2005",]

# common <- intersect(dia_sam_05[,"site_id"], psm_sam_05[,"site_id"]) # results in empty data

```
# Want to compare tables on year and site_id:
Extract year from date.
```{r  extract-year-from-date echo=TRUE, message=FALSE}
drv = dbDriver("PostgreSQL")
con = dbConnect(drv, dbname = DBname, user = DBuser, host = DBhost, port = DBport, password = DBpassword)

sam_tab = dbGetQuery(con, " SELECT dsam.site_id, dsam.date, psam.date, 
                    EXTRACT(YEAR FROM dsam.date) AS sam_year,
                    EXTRACT(YEAR FROM psam.date) AS psm_year
                     FROM dia.dia_samples AS dsam
                     INNER JOIN views.psm_samples_2005 AS psam 
                     ON dsam.site_id = psam.site_id
                    LIMIT 100");


dbDisconnect(con)
dbUnloadDriver(drv)
```

Select all diatom samples where environmental variable data was measured at the same site in the same year and where herbicides were detected.

```{r  join-relevant-variables, echo=TRUE, message=FALSE}
drv = dbDriver("PostgreSQL")
con = dbConnect(drv, dbname = DBname, user = DBuser, host = DBhost, port = DBport, password = DBpassword)

join = dbGetQuery(con, " SELECT DISTINCT ON (dsam.site_id, dsam.date, dsam.taxon) dsam.site_id, dsam.date, taxon, iz_n, cover, var.psm_type, var.name
                   FROM dia.dia_samples AS dsam
                   INNER JOIN views.psm_samples_2005 AS psam
                   ON dsam.site_id = psam.site_id
                   INNER JOIN phch.phch_variables var 
                   ON var.variable_id = psam.variable_id 
                     WHERE var.psm_type = 'herbicide'
                   AND ((dsam.date BETWEEN '2005-01-01' AND '2005-12-31'
                   AND psam.date BETWEEN '2005-01-01' AND '2005-12-31')
                OR (dsam.date BETWEEN '2006-01-01' AND '2006-12-31'
                   AND psam.date BETWEEN '2006-01-01' AND '2006-12-31')
                OR (dsam.date BETWEEN '2007-01-01' AND '2007-12-31'
                   AND psam.date BETWEEN '2007-01-01' AND '2007-12-31')
                OR (dsam.date BETWEEN '2008-01-01' AND '2008-12-31'
                   AND psam.date BETWEEN '2008-01-01' AND '2008-12-31')
               OR (dsam.date BETWEEN '2009-01-01' AND '2009-12-31'
                   AND psam.date BETWEEN '2009-01-01' AND '2009-12-31')
                OR (dsam.date BETWEEN '2010-01-01' AND '2010-12-31'
                   AND psam.date BETWEEN '2010-01-01' AND '2010-12-31')
                 OR (dsam.date BETWEEN '2011-01-01' AND '2011-12-31'
                   AND psam.date BETWEEN '2011-01-01' AND '2011-12-31')
                 OR (dsam.date BETWEEN '2012-01-01' AND '2012-12-31'
                   AND psam.date BETWEEN '2012-01-01' AND '2012-12-31')
                 OR (dsam.date BETWEEN '2013-01-01' AND '2013-12-31'
                   AND psam.date BETWEEN '2013-01-01' AND '2013-12-31')
                OR (dsam.date BETWEEN '2014-01-01' AND '2014-12-31'
                   AND psam.date BETWEEN '2014-01-01' AND '2014-12-31')
                OR (dsam.date BETWEEN '2015-01-01' AND '2015-12-31'
                   AND psam.date BETWEEN '2015-01-01' AND '2015-12-31'))
                   ORDER BY dsam.date, dsam.site_id, dsam.taxon
                   ")
# results in 45980 observations


dbDisconnect(con)
dbUnloadDriver(drv)
```

```{r  join-2005, echo=TRUE, message=FALSE}
drv = dbDriver("PostgreSQL")
con = dbConnect(drv, dbname = DBname, user = DBuser, host = DBhost, port = DBport, password = DBpassword)

# Since iz_n (species abundance) is often empty,  I instead choose cover for abundance data.

# join2005b = dbGetQuery(con, " SELECT DISTINCT ON (dsam.site_id, dsam.taxon, dsam.date) dsam.site_id, dsam.date, taxon, dsam.iz_n, cover, psam.date, var.psm_type, var.name
                   FROM dia.dia_samples AS dsam
                   INNER JOIN views.psm_samples_2005 AS psam
                   ON dsam.site_id = psam.site_id
                   INNER JOIN phch.phch_variables var 
                   ON var.variable_id = psam.variable_id 
                  WHERE var.psm_type = 'herbicide'
                   AND (dsam.date BETWEEN '2005-01-01' AND '2005-12-31'
                   AND psam.date BETWEEN '2005-01-01' AND '2005-12-31')
                  ORDER BY dsam.date, dsam.site_id, dsam.taxon
                   ")

dbDisconnect(con)
dbUnloadDriver(drv)
```
## Shorten taxon name
```{r  shorten-taxon-name, echo=TRUE, message=FALSE}
taxa_list <-unique(join$taxon)
taxa_cha <- as.character(taxa_list)
species_list <- sort(taxa_cha) #list of all species
species_list
nrow(as.data.frame(species_list)) # 931 different taxa in the dataset

taxa_genus <- sapply(strsplit(taxa_cha, ' '), '[', 1) # keeps only genus name
taxa_species <- sapply(strsplit(taxa_cha, ' '), '[', 2) # keeps only species name
genus_list<- sort(unique(taxa_temp))    #list of all genera
genus_list
nrow(as.data.frame(genus_list))

# Keep only Genus + species name.
join$taxon <- sub("^(\\S*\\s+\\S+).*", "\\1", join$taxon)
# Only 800 differet species left after shortening of the name.
```

# Subset data for specific years
```{r  subset-data-years, echo=TRUE, message=FALSE}
# within R and not via SQL query
join2005 <- subset(join, date < as.Date("2006-01-01"))
join2006 <- subset(join, (date < as.Date("2007-01-01"))&(date > as.Date("2005-12-31")))
join2007 <- subset(join, (date < as.Date("2008-01-01"))&(date > as.Date("2006-12-31")))
join2008 <- subset(join, (date < as.Date("2009-01-01"))&(date > as.Date("2007-12-31")))
join2009 <- subset(join, (date < as.Date("2010-01-01"))&(date > as.Date("2008-12-31")))
join2010 <- subset(join, (date < as.Date("2011-01-01"))&(date > as.Date("2009-12-31")))
join2011 <- subset(join, (date < as.Date("2012-01-01"))&(date > as.Date("2010-12-31")))
join2012 <- subset(join, (date < as.Date("2013-01-01"))&(date > as.Date("2011-12-31")))
join2013 <- subset(join, (date < as.Date("2014-01-01"))&(date > as.Date("2012-12-31")))
join2014 <- subset(join, (date < as.Date("2015-01-01"))&(date > as.Date("2013-12-31")))
join2015 <- subset(join, date > as.Date("2014-12-31"))

```

# Transform data with reshape2 package to get from long to wide data for the site_id.
```{r  transform-data-to-wide, echo=TRUE, message=FALSE}

# Create proper data format
dia05 <- data.frame(join2005$taxon, join2005$site_id, join2005$date, as.numeric(join2005$cover))
dia06 <- data.frame(join2006$taxon, join2006$site_id, join2006$date, as.numeric(join2006$cover))
dia07 <- data.frame(join2007$taxon, join2007$site_id, join2007$date, as.numeric(join2007$cover))
dia08 <- data.frame(join2008$taxon, join2008$site_id, join2008$date, as.numeric(join2008$cover))
dia09 <- data.frame(join2009$taxon, join2009$site_id, join2009$date, as.numeric(join2009$cover))
dia10 <- data.frame(join2010$taxon, join2010$site_id, join2010$date, as.numeric(join2010$cover))
dia11 <- data.frame(join2011$taxon, join2011$site_id, join2011$date, as.numeric(join2011$cover))
dia12 <- data.frame(join2012$taxon, join2013$site_id, join2013$date, as.numeric(join2013$cover))
dia13 <- data.frame(join2013$taxon, join2013$site_id, join2013$date, as.numeric(join2013$cover))
dia14 <- data.frame(join2014$taxon, join2014$site_id, join2014$date, as.numeric(join2014$cover))
dia15 <- data.frame(join2015$taxon, join2015$site_id, join2015$date, as.numeric(join2015$cover))

# Delete rows with missing values
dia05 <- dia05[complete.cases(dia05), ]
dia08 <- dia08[complete.cases(dia08), ]
dia09 <- dia09[complete.cases(dia09), ]
# if conducted for 2012, no samples are left.


# Rename the columns
names(dia05) <- c("taxon", "site_id", "date", "cover" )
names(dia06) <- c("taxon", "site_id", "date", "cover" )
names(dia07) <- c("taxon", "site_id", "date", "cover" )
names(dia08) <- c("taxon", "site_id", "date", "cover" )
names(dia09) <- c("taxon", "site_id", "date", "cover" )
names(dia10) <- c("taxon", "site_id", "date", "cover" )
names(dia11) <- c("taxon", "site_id", "date", "cover" )
names(dia12) <- c("taxon", "site_id", "date", "cover" )
names(dia13) <- c("taxon", "site_id", "date", "cover" )
names(dia14) <- c("taxon", "site_id", "date", "cover" )
names(dia15) <- c("taxon", "site_id", "date", "cover" )

# Aggregate with reshape2
require(reshape2)
cast05a <- dcast(dia05, taxon + date ~ site_id, fill = 0)

# Like this, same species appear several times if it was sampled on different sites on
# several dates in the year.


cast05 <- dcast(dia05, site_id ~ taxon, fill = 0) # length/amount of presence
cast05 <- dcast(dia05, site_id ~ taxon, fill = 0, fun.aggregate = mean) # mean of cover
cast05 <- dcast(dia05, site_id ~ taxon, fill = 0, min) # min of cover

#  In 2013 there is only one diatomeen sample and none in the years 2014 and 2015.
# (That meet the criteria that herbicides were sampled in the same year at the same site.)

# Aggregate with data.table
require(data.table)
cast05<- data.table::dcast(dia05, site_id ~ taxon, fill=0, fun=mean)
cast06<- data.table::dcast(dia06, site_id ~ taxon, fill=0, fun=mean)
cast07<- data.table::dcast(dia07, site_id ~ taxon, fill=0, fun=mean)
cast08<- data.table::dcast(dia08, site_id ~ taxon, fill=0, fun=mean)
cast09<- data.table::dcast(dia09, site_id ~ taxon, fill=0, fun=mean)
cast10<- data.table::dcast(dia10, site_id ~ taxon, fill=0, fun=mean)
cast11<- data.table::dcast(dia11, site_id ~ taxon, fill=0, fun=mean)
cast12<- data.table::dcast(dia12, site_id ~ taxon, fill=0, fun=mean)
cast13<- data.table::dcast(dia13, site_id ~ taxon, fill=0, fun=mean)
cast14<- data.table::dcast(dia14, site_id ~ taxon, fill=0, fun=mean)
cast15<- data.table::dcast(dia15, site_id ~ taxon, fill=0, fun=mean)

# removal of site information
cast05 <-cast05[, -1] 
cast06 <-cast06[, -1]
cast07 <-cast07[, -1] 
cast08 <-cast08[, -1]
cast09 <-cast09[, -1] 
cast10 <-cast10[, -1]
cast11 <-cast11[, -1] 
cast12 <-cast12[, -1]
cast13 <-cast13[, -1] 
cast14 <-cast14[, -1]
cast15 <-cast15[, -1] 


# aggregation function needed if variables do not identify a single observation for
# each output cell. Defaults to length (with a message) if needed but not specified.
# eg Achnanthes minutissima var. minutissima is present twice at site_id NW_137315
# Answer: Result of if same site was sampled twice in one year.

# dcast ( tab, taxon ~ site_id + year ) would also be possible
```


```{r  remove-rare-species, echo=TRUE, message=FALSE}
# presence-absence transformation to calculate species number per site
require(vegan)
cast05_pa <-decostand(cast05, "pa") 
cast06_pa <-decostand(cast06, "pa") #works
cast07_pa <-decostand(cast07, "pa") #works
cast08_pa <-decostand(cast08, "pa")
cast09_pa <-decostand(cast09, "pa")
cast10_pa <-decostand(cast10, "pa") #works
cast11_pa <-decostand(cast11, "pa") #works
cast12_pa <-decostand(cast12, "pa")
# NAs in some cells. There, probably, not cover was measured but abundance/iz_n
# How many times does this happen?
sum(is.na(dia05$cover)) #1   # from 1704
sum(is.na(dia06$cover)) #0   
sum(is.na(dia07$cover)) #0
sum(is.na(dia08$cover)) #246 # from 4949
sum(is.na(dia09$cover)) #981 # from 10581
sum(is.na(dia10$cover)) #0   
sum(is.na(dia11$cover)) #0
sum(is.na(dia12$cover)) #8055 # from 8055
# try with again with removing all rows that have NAs. (done above)

# calculate sum per species
spec_sum05 <- apply(cast05_pa,2,sum)
sort(spec_sum05)
spec_sum06 <- apply(cast06_pa,2,sum)
sort(spec_sum06)
spec_sum07 <- apply(cast07_pa,2,sum)
sort(spec_sum07)
spec_sum08 <- apply(cast08_pa,2,sum)
spec_sum09 <- apply(cast09_pa,2,sum)
spec_sum10 <- apply(cast10_pa,2,sum)
sort(spec_sum10)
spec_sum11 <- apply(cast11_pa,2,sum)
sort(spec_sum11)


# remove species that occur at less than 2 sites
# spec_sum needs to be calculated with number of presence data and here continued with cover data
spec_fin05 <- cast05[, ! spec_sum05 <2]
sort(apply(spec_fin05, 2, max))   #check if it worked
spec_fin06 <- cast06[, ! spec_sum06 <2]
sort(apply(spec_fin06, 2, max))
spec_fin07 <- cast07[, ! spec_sum07 <2]
sort(apply(spec_fin07, 2, max))
spec_fin08 <- cast08[, ! spec_sum08 <2]
spec_fin09 <- cast09[, ! spec_sum09 <2]
spec_fin10 <- cast10[, ! spec_sum10 <2]
sort(apply(spec_fin10, 2, max))
spec_fin11 <- cast11[, ! spec_sum11 <2]
sort(apply(spec_fin11, 2, max))


```

Conduct DCA to see if axis length indicates unimodal gradient.
```{r  dca, echo=TRUE, message=FALSE}
require(vegan)
# axis lenght = SD. For axis length < 3, linear analysis should be used, for axis length >3, unimodal analysis should be performed.
# If presence-absence data is used: DCA1 length = 2.5
# If cover data is used: DCA1 length = 3.6 --> unimodal approach would be fine.
# Don't use decorana-values.
spec_dca05<- decorana(spec_fin05)
spec_dca05 #DCA1 length = 3.66
# summary(spec_dca05, digits=3, origin=TRUE, display="both")

plot(spec_dca05, display="both") 
# crosses=species, points=sites
# shnam <- make.cepnames(names(spec_fin)) #abbreaviation of Latin names

spec_dca06<- decorana(spec_fin06)
spec_dca06 #DCA1 length = 7.48

spec_dca07<- decorana(spec_fin07)
spec_dca07 #DCA1 length = 4.83

spec_dca08<- decorana(spec_fin08)   # many samples deleted before
spec_dca08 #DCA1 length = 4.84

spec_dca09<- decorana(spec_fin09)   # many samples deleted before
spec_dca09 #DCA1 length = 2.39

spec_dca10<- decorana(spec_fin10)
spec_dca10 #DCA1 length = 4.31

spec_dca11<- decorana(spec_fin11)
spec_dca11 #DCA1 length = 6.13

# Conducting unimodal analysis would be okay for all years except for 2009.
```
Conduct CA
```{r  ca, echo=TRUE, message=FALSE}
# conduct CA
spec_ca <- cca(spec_fin)
spec_ca
plot(spec_ca) # species scores as weighted averages of site scores.
chisq.test(spec_fin/sum(spec_sum))
# x-squared = inertia from aboce, p-values not important
plot(spec_ca, scaling =1) #site scores as weighted averages of species scores


```

# Creating a data frame
```{r  create-data-frame, echo=TRUE, message=FALSE}
drv = dbDriver("PostgreSQL")
con = dbConnect(drv, dbname = DBname, user = DBuser, host = DBhost, port = DBport, password = DBpassword)

# Functions not needed at the moment but keep them anyways, just in case.

dia_sam_year = dbGetQuery(con, " SELECT *, 
                    EXTRACT(YEAR FROM dsam.date) AS year
                     FROM dia.dia_samples AS dsam
                    WHERE date >= '2005-01-01'
                    ")
dia_sam_year = dbGetQuery(con, " SELECT dsam.id_rs, dsam.id_pn, dsam.date, dsam.dv, dsam.iz_n, dsam.iz_b, dsam.cover, dsam.site_id, dsite.site_nr, 
                    EXTRACT(YEAR FROM dsam.date) AS year
                     FROM dia.dia_samples AS dsam
                     JOIN dia.dia_sites AS dsite 
                     ON dsam.site_id = dsite.site_id                  
                    WHERE date >= '2005-01-01'
                    ")

psm_sam_year = dbGetQuery(con, " SELECT  psam.sample_id, psam.site_id,psam.date, psam.qualifier, psam.value, psam.unit, var.name, var.cas, var.pgroup, var.psm_type, var.pan_class, psite.site_nr,
                    EXTRACT(YEAR FROM psam.date) AS year
                     FROM views.psm_samples_2005 AS psam
                      JOIN phch.phch_variables var 
                      ON var.variable_id = psam.variable_id
                      JOIN views.psm_sites_2005 AS psite 
                      ON psam.site_id = psite.site_id                    
                      WHERE date >= '2005-01-01'
                     AND var.psm_type = 'herbicide'
                    LIMIT 1000")

# Create the data frame
samples <- merge(dia_sam_year, psm_sam_year, by = c("site_nr","year"))
samples <- merge(dia_sam_year, psm_sam_year, by = "year")
samples2 <- merge(dia_sam_year, psm_sam_year, by = "site_nr")
# Works for year but not for site_nr.
#Error: cannot allocate vector of size 4.4 Gb -> if 100000 objects in both dataframes
# merge by site_id results in emtpy data
# results in empty data

dbDisconnect(con)
dbUnloadDriver(drv)
```



## Taxon frequency
Are there any rare species? Marchant (2002) suggests to remove rare species and Cao et al.(2001) suggests this if samples were taken over a large spatial scale which holds true for the present data. So the question is what a suitable definition for rare species is. E.g. species that occur in only 1 sample.

```{r  taxon-frequency, echo=TRUE, message=FALSE}

# taxon_count <- table(dia_sam$dv)
taxon_count <- table(join$taxon)
# taxon_count <- table(dia_sam$taxon)
summary(taxon_count)
taxon_count <-as.data.frame(taxon_count)
taxon_count <- taxon_count[order(taxon_count$Freq),]
head(taxon_count)
freqn <- nrow(taxon_count) # 931   #800 after name shortening
freq3 <- nrow(taxon_count[taxon_count$Freq<5,]) # 383   # 327 after name shortening
freq2 <- nrow(taxon_count[taxon_count$Freq<3,]) # 274   # 229 after name shortening
freq1 <- nrow(taxon_count[taxon_count$Freq<2,]) # 172   # 141 after name shortening
hist(taxon_count$Freq, breaks = 50)   

# relative frequency of species that are only present at 1 site
freq1/freqn*100       # 17.6 % of all species are only present at 1 site
freq1/nrow(join)*100 # 0.3 % of all Samples-site combinations represent a species that was sampled only once.


# Sollte ich seltene Arten weglassen? Wenn ja, welche Arten stufe ich als selten ein?
```
The distribution of species frequency is very left-skewed. Most speces are present in less than ~200 samples and few are present in more than 200 samples.

```{r  read-taxalisten-data, echo=TRUE, message=FALSE}
samples_taxon <- merge(dia_sam_year, diatom_dat, by.x="dv", by.y="DV")
diatom_dat1<- read.table("C_Proben_Taxalisten.txt",header=T,sep="\t",dec=".")

```

```{r  suggestions-andreas, echo=TRUE, message=FALSE}
require(data.table)    # good for subsampling --> datacamp course
iris_dt <- as.data.table(iris)
class(iris_dt)
head(iris_dt)
iris_dt[i = 1:100, j = mean(Sepal.Length), by = Species]
diatom_dat1 <- fread("C_Proben_Taxalisten.txt") # schnellere funktion als read.csv usq. auch: fwrite()


require(dplyr)     # good for subsampling

iris$Sepal.Length
# with base package:
aggregate(iris$Sepal.Length, by = list(iris$Species), mean)

```


```{r get-variables, echo=TRUE, message=FALSE}
drv = dbDriver("PostgreSQL")
con = dbConnect(drv, dbname = DBname, user = DBuser, host = DBhost, port = DBport, password = DBpassword)


var_names = dbGetQuery(con, "SELECT DISTINCT var.name
                                FROM phch.phch_samples sam
                                JOIN phch.phch_variables var ON var.variable_id = sam.variable_id
                                ")
# Nitrit, Nitrat-Stickstoff, Kalium, Sichttiefe, Chlorid, Nitrat, Gesamt-Phosphor, Sauerstoffgehalt, Sauerstoffzehrung nach 5 (7) Tagen ohne Hemmer, Gesamt-Stickstoff, Stickstoff, Wasserstand (OFW), pH-Wert (Feld) Ammonium-Stickstoff, Sauerstoffzehrung nach 7 Tagen mit Hemmer, BSB5, sedimentiert, Sauerstoffzehrung nach 21 Tagen mit Hemmer, TrÃ¼bung (physiko-chem. Messung), Elektrische LeitfÃ¤higkeit (20Â°C), Nitrit-Stickstoff, Natrium, Sulfat, Ammonium, Abfluss, spektraler Absorptionskoeffizient 436nm, freie KohlensÃ¤ure, SauerstoffsÃ¤ttigung, Stickstoff, Hydrogenkarbonat, Eisen, Wassertemperatur, Magnesium, Gesamtphosphor als PO4, Phosphor, Chemischer Sauerstoffbedarf

dbDisconnect(con)
dbUnloadDriver(drv)
```

```{r load-ec50-data, echo=TRUE, message=FALSE}
drv = dbDriver("PostgreSQL")
con = dbConnect(drv, dbname = DBname, user = DBuser, host = DBhost, port = DBport, password = DBpassword)

ec50 = dbGetQuery(con, "SELECT variable_id, name, n_al, ec50_al_fr_min, ec50_al_fr_min_taxa, ec50_al_fr_perc20, ec50_al_fr_mean
                                FROM phch.phch_ec50
                                LIMIT 100
                                ")


dbDisconnect(con)
dbUnloadDriver(drv)
```