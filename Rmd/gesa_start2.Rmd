---
title: "Untitled"
author: "Gesa Amelung"
date: "7 November 2017"
output:
  pdf_document: default
  html_document: default
bibliography: rpc_lit.bib
editor_options: 
  chunk_output_type: console
  
---

# Data Analysis

## Setup

The following packages and the data base access script was loaded.

```{r setup, echo=TRUE, message=FALSE}
## load packages
require(RPostgreSQL)
require(sf)
require(knitr)
require(mapview)
require(data.table)
require(dplyr)
require(vegan)
require(ggplot2)
require(gridExtra)
require(stringr)

## switch
online = FALSE

## load access data
path = getwd()
source(file.path(path, 'amelung_access.R'))
```

## Loading data

### Pesticide data

The pesticide data was loaded including the samples, the sites and geographic information of the sites.

```{r load-PSM-data, echo=TRUE, eval=FALSE, message=FALSE}
if (online) {
  drv = dbDriver("PostgreSQL")
  con = dbConnect(drv, dbname = DBname, user = DBuser, host = DBhost, port = DBport, password = DBpassword)
  
  psm_sites_geo = st_read_db(con, query = "SELECT *
                                           FROM views.psm_sites_2005")
  psm_sites = as.data.frame(psm_sites_geo)
  psm_sam = dbGetQuery(con, "SELECT *
                                 FROM views.psm_samples_2005 sam
                                 JOIN phch.phch_variables var
                                ON var.variable_id = sam.variable_id")
  psm_sam = psm_sam[ ,-c(16, 24)] # delete duplicate rows
  
  dbDisconnect(con)
  dbUnloadDriver(drv)
  
  saveRDS(psm_sites_geo, file.path('cache', 'psm_sites_geo.rds'))
  saveRDS(psm_sites, file.path('cache', 'psm_sites.rds'))
  saveRDS(psm_sam, file.path('cache', 'psm_sam.rds'))
} else {
  psm_sites_geo <- readRDS(file.path('cache', 'psm_sites_geo.rds'))
  psm_sites <- readRDS(file.path('cache', 'psm_sites.rds'))
  psm_sam <- readRDS(file.path('cache', 'psm_sam.rds'))
}

psm_sam = psm_sam %>%
  filter(psm_type == 'herbicide' & date > '2004-12-31')
## AS: when the script is finished we could also consider applying it to all pesticides

# Create column for year
psm_sam$year <- format(psm_sam$date, '%Y')
psm_sam$month <- format(psm_sam$date, '%m')
psm_sam$day <- format(psm_sam$date, '%j')
```

### Diatom data
```{r load-diatom-data, echo=TRUE, message=FALSE}
if (online) {
  drv = dbDriver("PostgreSQL")
  con = dbConnect(drv, dbname = DBname, user = DBuser, host = DBhost, port = DBport, password = DBpassword)
  # dia_sites = dbGetQuery(con, "SELECT * FROM dia.dia_sites") ##AS: no need to extra load this
  dia_sites_geo = st_read_db(con, query = "SELECT * FROM dia.dia_sites")
  dia_sites = as.data.frame(dia_sites_geo)
  dia_sam = dbGetQuery(con, "SELECT *
                         FROM dia.dia_samples
                         WHERE date > '2004-12-31'
                         ")
  dbDisconnect(con) 
  dbUnloadDriver(drv)
  
  saveRDS(dia_sites_geo, file.path('cache', 'dia_sites_geo.rds'))
  saveRDS(dia_sites, file.path('cache', 'dia_sites.rds'))
  saveRDS(dia_sam, file.path('cache', 'dia_sam.rds'))

} else {
  
  dia_sites_geo = readRDS(file.path('cache', 'dia_sites_geo.rds'))
  dia_sites = readRDS(file.path('cache', 'dia_sites.rds'))
  dia_sam = readRDS(file.path('cache', 'dia_sam.rds'))
}

# Create column for species name only. Add "sp." to those names that only have genera 
dia_sam$species <- gsub('[[:punct:]]', '', dia_sam$taxon) # remove punctuation characters
dia_sam$species <- gsub('([a-z]+)\\s([a-z]+)(.+)*', '\\1 \\2', dia_sam$species) # reduce to two strings (removes: 'var', 'form')
dia_sam$species <- ifelse(str_count(dia_sam$species, pattern = '\\s') == 0,
                          paste0(dia_sam$species, ' sp.'),
                          dia_sam$species)

# table(str_count(dia_sam$species, pattern = '\\s')) # count space characters (only 1s should be left) ##AS: tests for two name taxa

# Create column for genus name
dia_sam$genus <- sub("^(\\S*).*", "\\1", dia_sam$taxon)

# Create column for year
dia_sam$year <- format(dia_sam$date, '%Y')
dia_sam$month <- format(dia_sam$date, '%m')
dia_sam$day <- format(dia_sam$date, '%j')
```

### River network
```{r load-river-network}
if (online) {
  drv = dbDriver("PostgreSQL")
  con = dbConnect(drv, dbname = DBname, user = DBuser, host = DBhost, port = DBport, password = DBpassword)
  
  streams = st_read_db(con, query = "SELECT * FROM spatial.gewaessertyp")
  
  dbDisconnect(con)
  dbUnloadDriver(drv)
  
  saveRDS(streams, file.path('cache', 'streams.rds'))

} else {
  
  streams = readRDS(file.path('cache', 'streams.rds'))
}
```

### Load physical-chemical data
```{r load-phch-data, echo=TRUE, message=FALSE}
if (online) {
  drv = dbDriver("PostgreSQL")
  con = dbConnect(drv, dbname = DBname, user = DBuser, host = DBhost, port = DBport, password = DBpassword)

  phch_sam = dbGetQuery(con, "SELECT *
                              FROM phch.phch_samples sam
                              LEFT JOIN phch.phch_variables var ON var.variable_id = sam.variable_id
                                  WHERE date > '2004-12-31' AND date < '2016-01-01'")
  dbDisconnect(con)
  dbUnloadDriver(drv)
  
  saveRDS(phch_sam, file.path('cache', 'phch_sam.rds'))
} else {
  phch_sam = readRDS(file.path('cache', 'phch_sam.rds'))
}

phch_sam = phch_sam[ , -c(16, 24)] # removes duplicated unit, variable_id entries

# Get only data that are not psm or psm = herbicide
#phch_sam <- phch_sam[phch_sam$psm_type%in%c("herbicide", ""),] # 9,620,631 datapoints
# get onlly data that are no chemicals or are herbicides.
phch_sam <- phch_sam %>%
  filter(casnr =="" | psm_type=="herbicide")
# 5,268,995 datapoints
nrow(phch_sam[phch_sam$casnr=="",])

phch_sam$year <- format(phch_sam$date, '%Y')  # Create column for year
phch_sam$month <- format(phch_sam$date, '%m') # Create column for month
phch_sam$day <- format(phch_sam$date, '%j')   # Create column for day of the year

```

### Load ec50 data

```{r load-ec50-data, echo=TRUE, message=FALSE}
if (online) {
  drv = dbDriver("PostgreSQL")
  con = dbConnect(drv, dbname = DBname, user = DBuser, host = DBhost, port = DBport, password = DBpassword)

ec50 = dbGetQuery(con, "SELECT casnr, subst_name, ec50f_al4896_fin
                                FROM phch.phch_ec50_fin
                  ")
  dbDisconnect(con)
  dbUnloadDriver(drv)
  
  saveRDS(ec50, file.path('cache', 'ec50.rds'))
} else {
  ec50 = readRDS(file.path('cache', 'ec50.rds'))
}
```

### Load landuse data

```{r load-landuse-data, echo=TRUE, message=FALSE}
if (online) {
  drv = dbDriver("PostgreSQL")
  con = dbConnect(drv, dbname = DBname, user = DBuser, host = DBhost, port = DBport, password = DBpassword)

landuse = dbGetQuery(con, "SELECT site_id, atkis_perc
                                FROM spatial_derived.land_use_ezg30
                  ")
  dbDisconnect(con)
  dbUnloadDriver(drv)
  
  saveRDS(landuse, file.path('cache', 'landuse.rds'))
} else {
  landuse = readRDS(file.path('cache', 'landuse.rds'))
}
```

Join physical-chemical data with EC50 data.
```{r join-ec50}
nrow(phch_sam) # 5268995
# Join phch with ec50 to include casnr
phch_sam = left_join(phch_sam, ec50, by = "casnr")

# Remove all rows that are pesticides but don't have a ec50f_al4896_fin  entry
# Keep all rows that have a EC50 value or that are no pesticides.

phch_sam = phch_sam %>%
  filter(!ec50f_al4896_fin=="" | psm == FALSE)

nrow(phch_sam) #5113250

```


## Data preparation

For the CCA later on, a dataset was created containing only diatom samples where herbicides were measured at the same site in the same month (`dia_sam_cca`). For the CA, all samples were retained in order to have a larger dataset  (`dia_sam`).

```{r join-on-site-year, echo=TRUE, message=FALSE}
# Diatom data

dia_sam_cca <- semi_join(dia_sam, phch_sam[phch_sam$psm==TRUE & !phch_sam$value_fin == 0,], by = c("site_id", "month"))
nrow(dia_sam_cca) # 37415

##AS: like this you can keep it an sf-object:
##AS: generally you can handle sf-Objects with dplyr like data.frames and tibbles
#dia_sites_cca <- dia_sites_geo[ dia_sites_geo$site_id %in% psm_sites_geo$site_id, ]
```


### Usage of cover data as quantitative variable
In most cases, diatom cover was measured instead of abundance. Therefore, rows where abundance was measured were deleted. Instead, the cover data is used as the quantitative variable in the following analyses. The deletion of irrelevant rows was performed for the datasets for CA and CCA seperately.

```{r delete-abundance-data, echo=TRUE, message=FALSE}
dia_sam <- dia_sam[!is.na(dia_sam$cover), ]
dia_sam <- dia_sam[,-6]    #delete column with abundance data

dia_sam_cca <- dia_sam_cca[!is.na(dia_sam_cca$cover), ]
dia_sam_cca <- dia_sam_cca[,-6] 
```

## Visualization of the sampling frequency

Sampling days and sampling events per year.

```{r sampling-days-per-year, echo=TRUE, message=FALSE}
## Number of samples

# Count number of samples per month and year
sample_count_ym = dia_sam %>%
  group_by(year, month) %>%
  summarise(N = n()) %>%
   as.data.frame()

# Count number of samples per year
sample_count_y = dia_sam %>%
  group_by(year) %>%
  summarise(N = n()) %>%
   as.data.frame()

## Number of sampling events

# Count number of sampling events (id_pn) per year
event_count_y <- dia_sam %>% 
  group_by(year) %>%
  summarise(N = n_distinct(id_pn))  %>%
   as.data.frame()

# Count number of sampling events per month and year
event_count_ym <- dia_sam %>% 
  group_by(year, month) %>%
  summarise(N = n_distinct(id_pn))  %>%
   as.data.frame()

## Plots

# Plot: Number of samples per month and year
gg1 <- ggplot(sample_count_ym, aes(y = N, x = month)) +
  geom_point() +
  facet_wrap( ~ year) +
  ggtitle ("number of diatom samples per month and year")
gg1

# Plot: Number of sampling events per month and year
gg2 <- ggplot(event_count_ym, aes(y = N, x = month)) +
  geom_point() +
  facet_wrap( ~ year) +
  ggtitle ("number of diatom sampling events per month and year")
gg2

## Plot: Sampling counts per year & Event counts per year
gg3 <- ggplot(dia_sam, aes(x=year)) +
  geom_bar() +
  labs(title="diatom samples per year", x = "year", y = "sample counts")

gg4 <- ggplot(event_count_y, aes(x=year, y = N)) +
  geom_bar(stat="identity") +
  labs(title="events per year", x = "year", y = "event counts")

grid.arrange(gg3, gg4, ncol=2)

# number of samples per month
gg5 <- ggplot(dia_sam, aes(x=month)) +
  geom_bar() +
  labs(title="diatom samples per month", x = "month", y = "number of samples")
gg5
ggsave(gg5, width = 4, height = 4, filename = "figures/n_month.png")

# number of samples per month and year
gg6 <- ggplot(sample_count_ym, aes(y = N, x = year)) +
  geom_point() +
  facet_wrap( ~ month) +
  ggtitle ("number of diatom samples per year and month")
gg6
ggsave(gg6, width = 10, height = 10, filename = "figures/n_my.png")

sam_ym <- dcast(sample_count_ym, year ~ month, fill = "-")

# number of sampes per day
gg07 <- ggplot(dia_sam[dia_sam$month=="07",], aes(x=day)) +
  geom_bar() +
  ylim(0, 1750) +
  labs(title="diatom samples per day - July", x = "day", y = "number of samples")

gg08 <- ggplot(dia_sam[dia_sam$month=="08",], aes(x=day)) +
  geom_bar() +
  ylim(0, 1750) +
  labs(title="diatom samples per day - August", x = "day", y = "number of samples")

gg09 <- ggplot(dia_sam[dia_sam$month=="09",], aes(x=day)) +
  geom_bar() +
  ylim(0, 1750) +
  labs(title="diatom samples per day - September", x = "day", y = "number of samples")

gg7 <- grid.arrange(gg07, gg08, gg09, ncol=3)
ggsave(gg7, width = 22, height = 10, filename = "figures/n_july_sept.png")

```

It seems like the distribution of samples and sampling events is very similar. This means that on every sampling day and event, a similar number of samples was taken. 

One month of the early and the late application season, respectively, were to be chosen for further analysis. Even though most samples were available for the month August, to compare July and September seemed more suitable. 

```{r herbicides-sampling-overview, echo=TRUE, message=FALSE}
psm_count_ym = phch_sam %>%
  filter(psm == TRUE) %>%
  group_by(year, month) %>%
  summarise(N = n()) %>%
   as.data.frame()

psm_gg1 <- ggplot(phch_sam[phch_sam$psm==TRUE,], aes(x=month)) +
  geom_bar() +
  labs(title="herbicide samples per month", x = "month", y = "number of samples")
psm_gg1
ggsave(psm_gg1, width = 4, height = 4, filename = "figures/n_psm_month.png")

psm_gg2<- ggplot(psm_count_ym, aes(y = N, x = year)) +
  geom_point() +
  facet_wrap( ~ month) +
  ggtitle ("number of herbicide samples per year and month")
psm_gg2
ggsave(psm_gg2, width = 10, height = 10, filename = "figures/n_psm_my.png")

psm_gg3 <- ggplot(phch_sam[phch_sam$psm==TRUE,], aes(x=year)) +
  geom_bar() +
  labs(title="herbicide samples per year", x = "year", y = "sample counts")
psm_gg3
```

Herbicides were sampled in all month with a high intensity. Generally, less samples were taken in the winter months. According to this continuous high amount of data, no months have to be excluded based on that. The amount of diatom data would be the more conservative proxy to gudge which months are appropriate to use for further analyses.
In 2015, almost no herbicide samples were taken. Also, the year 2014 was not so frequently sampled.

```{r remove-months}
dia_sam = dia_sam %>%
  filter(month %in% c("07",  "09"))

dia_sam_cca = dia_sam_cca %>%
  filter(month %in% c("07", "09"))
  
```

## Taxon frequency
[@Marchant.2002] suggests to remove rare species as only common species produce information that can reliably be linked to present environmental gradients. [@Cao.2001] suggests the removal of rare species if samples were taken over a large spatial scale which holds true for the present dataset. Furthermore, Chi-square distance, which is the distance measure used in CA and CCA, gives more weight to rare species. Due to this reason, (@Legendre.2012) suggest to remove rare species from the analysis. Here, 4 datasets are created: Species and genera that occur at less than 20 % of the sites were removed, respectively and species and genera that occur in less than 5 % of the samples were removed, respectively (@Fernandez.2016).

The analysis was done for both, species and genus data and therefore, all procedures were performed for species data and genus data seperately from here on. According to (@Rimet.2012), analysis with a taxonomic resolution of genus performs as well as a resolution of species level in many cases. Similarly, (@Larras.2014) found that diatom sensitivity to herbicides can be attributed to their phylogeny. They reported that centric and araphid diatoms (Thalassiosirales and Fragilariales, respectively
) were most sensitive to the herbicides whereas pennates (Cymbellales, Naviculales and Bacillariales)
) were more robust.

```{r  delete-rare-taxa, echo=TRUE, message=FALSE}
## Rare = taxa that occur at less than 5 % of the samples
sampleN = length(unique(dia_sam$id_pn))
n_sp <- length(unique(dia_sam$species))
n_ge <- length(unique(dia_sam$genus))

## Rare genera
dia_sam_ge = dia_sam %>%
  group_by(genus) %>%
  mutate(perc = n_distinct(id_pn) / sampleN) %>%
  arrange(-perc) %>%
  filter(perc >= 0.05)

# precentage of genera remaining after removal of rare genera
n_ge_abu <-length(unique(dia_sam_ge$genus)) #44
n_ge_abu
n_ge_abu/n_ge*100 # 57.1 %

# Plot
dia_sam_N_ge = dia_sam_ge %>%
       group_by(genus) %>%
       summarise(N=n())
plot(density(dia_sam_N_ge$N), main="Genus density")
# Histogram

## Rare species
dia_sam_sp = dia_sam %>%
  group_by(species) %>%
  mutate(perc = n_distinct(id_pn) / sampleN) %>%
  arrange(-perc) %>%
  filter(perc >= 0.05)

# precentage of genera remaining after removal of rare genera
n_sp_abu <-length(unique(dia_sam_sp$species)) # 153
n_sp_abu
n_sp_abu/n_sp*100 # 17.7 %

# Plot
dia_sam_N_sp = dia_sam_sp %>%
       group_by(species) %>%
       summarise(N=n())
plot(density(dia_sam_N_sp$N), main="Species density")

## Rare genera of dia_sam_cca dataset
sampleN_cca = length(unique(dia_sam_cca$id_pn))
n_ge_cca <- length(unique(dia_sam_cca$genus))

## Rare genera
dia_sam_ge_cca = dia_sam_cca %>%
  group_by(genus) %>%
  mutate(perc = n_distinct(id_pn) / sampleN_cca) %>%
  arrange(-perc) %>%
  filter(perc >= 0.05)

# precentage of genera remaining after removal of rare genera
n_ge_abu_cca <-length(unique(dia_sam_ge_cca$genus)) #43
n_ge_abu_cca
n_ge_abu_cca/n_ge_cca*100 # 59.7 %

# Plot
dia_sam_N_ge_cca = dia_sam_ge_cca %>%
       group_by(genus) %>%
       summarise(N=n())
plot(density(dia_sam_N_ge_cca$N), main="Genus density")


```

```{r explore diatom-data}
# min and max values of cover
range(dia_sam_ge$cover)
# count cases for each cover class
cov <- table(unlist(dia_sam_ge$cover))
# barplot of the cover distribution
barplot(cov, las=1, xlab ="cover class", ylab="frequency")
# Number of zero cover
sum(dia_sam_ge$cover==0)

# Species occurences: Numver of sampling dates where each species is present


#--> continue with numerical ecology with R
```


## Transform data to get from long to wide data

For the subsequent analysis, the data needed to be transformend from long to wide format. If several combinations of (`site_id`)  and (`species`) were present, the 95th percentile was taken to aggregate them. Further, the first column was stored as rowname. The aggregation was first performed over all years and over all months seperately.

#### graphical inspection of years
```{r ggplot-year}
# overview plots

length(unique(dia_sam$site_id)) ##AS: 1194

gr1 = ggplot(dia_sam, aes(y = site_id, x = month)) +
  geom_raster(aes(fill = year)) +
  facet_wrap( ~ year)
gr1

ggsave(gr1, width = 8, height = 5, filename = '/tmp/dia_sam.png')

gr2 = ggplot(dia_cov, aes(y = site_id, x = year)) +
  geom_raster(aes(fill = log10(cover+1)))
gr2
##AS: Maybe skip 2013/14?

gr3 = ggplot(dia_cov) +
  geom_raster(aes(y = site_id, x = day, fill = year))
gr3
```

### Aggregation per month

The data were aggregated per month by the 95th percentile of the cover. The data were then transformed from long to wide format.

Diatom communities follow a seasonal succession which might be more prominent than the interanual succession. (@Hausmann.2007) showed that for lakes, the spring and summer conditions had a strong impact on the diatom composition and productivity that was stronger than the impact of changing annual mean temperatures. Similarly,  (@Kirilova.2008) observed a seasonal succession of diatoms in  lakes. The predominant diatoms in winter and spring were of the genus *Stephanodiscus* while species of the genera *Stephanodiscus*, *Fragilaria*, and *Nitzschia* were the most abundant diatoms in summer and autumn. To account for this seasonal variability of diatom composition, it seemed reasonable to summarize the diatom data for each month over all years.
 
#### Species

```{r cast-species, echo=TRUE, message=FALSE}
dia_aggr_sp <- dia_sam_sp %>% 
  group_by(month, species, site_id) %>%
  summarise(mean = mean(cover),
            perc95 = quantile(cover, 0.95, na.rm = TRUE),
            total = n()) %>%
  arrange(species)

# Store single years as seperate elements of a list
dia_aggr_split_sp <- split(dia_aggr_sp, dia_aggr_sp$month)

cast_sp <- lapply(dia_aggr_split_sp, function(x) dcast(x, site_id ~ species, value.var="perc95", fill = 0))

# Take the first column and store it as a rowname, afterwards, delete the first column.
cast_sp <- lapply(cast_sp,
                     function(x) { rownames(x) <- x[,1];
                                   x[,1] <- NULL;
                                   x })

# Remove rows where the row sum is zero.
cast_sp <- lapply(cast_sp,
       function(x) { x[rowSums(x) > 0,] })
```

#### Genus

```{r cast-genus, echo=TRUE, message=FALSE}
dia_aggr_ge <- dia_sam_ge %>% 
  group_by(month, genus, site_id) %>%
  summarise(mean = mean(cover),
            perc95 = quantile(cover, 0.95, na.rm = TRUE),
            total = n()) %>%
  arrange(genus)

# Store single months as seperate elements of a list
dia_aggr_split_ge <- split(dia_aggr_ge, dia_aggr_ge$month)

cast_ge <- lapply(dia_aggr_split_ge, function(x) dcast(x, site_id ~ genus, value.var="perc95", fill = 0))

# Take the first column and store it as a rowname, afterwards, delete the first column.
cast_ge <- lapply(cast_ge,
                     function(x) { rownames(x) <- x[,1];
                                   x[,1] <- NULL;
                                   x })

# Remove rows where the row sum is zero.
cast_ge <- lapply(cast_ge,
       function(x) { x[rowSums(x) > 0,] })
```

#### Genus - CCA dataset

```{r cast-genus-cca, echo=TRUE, message=FALSE}
dia_aggr_ge_cca <- dia_sam_ge_cca %>% 
  group_by(month, genus, site_id) %>%
  summarise(mean = mean(cover),
            perc95 = quantile(cover, 0.95, na.rm = TRUE),
            total = n()) %>%
  arrange(genus)

# Store single months as seperate elements of a list
dia_aggr_split_ge_cca <- split(dia_aggr_ge_cca, dia_aggr_ge_cca$month)

cast_ge_cca <- lapply(dia_aggr_split_ge_cca, function(x) dcast(x, site_id ~ genus, value.var="perc95", fill = 0))

# Take the first column and store it as a rowname, afterwards, delete the first column.
cast_ge_cca <- lapply(cast_ge_cca,
                     function(x) { rownames(x) <- x[,1];
                                   x[,1] <- NULL;
                                   x })

# Remove rows where the row sum is zero.
cast_ge_cca <- lapply(cast_ge_cca,
       function(x) { x[rowSums(x) > 0,] })
```

```{r save-final-psm-datasets}

#saveRDS(cast_ge_cca, file.path('cache', 'dia_ge_final.rds'))
cast_ge_cca <- readRDS(file.path('cache', 'dia_ge_final.rds'))
                         
```

### DCA

A Detrended Correspondance Analysis (DCA) was performed in order to decide whether it is appropriate to conduct a unimodal gradient method. DCA was introduced by (@Hill.1980). If the length of the first DCA axis, scaled in units of standard deviations (S.D.), is > 4 S.D. a complete species turnover can be assumed and a unimodal gradient method is appropriate to use. A linear gradient method would be more appropriate for a length of the first axes < 3 S.D., indicating an incomplete change of species composition. For an axis length between 3 and 4, both types of methods are appropriate to use (@Leps.2003).

#### Species

```{r dca-species, echo=TRUE, message=FALSE}
lapply(cast_sp, function(x) {decorana(x)})
lapply(cast_sp, function(x) {plot(decorana(x), display="both")})
```
The legth of the first axis is > 3 S.D. in all months and therefore, a unimodal gradient can be assumed for all months.

#### Genus
```{r dca-genus, echo=TRUE, message=FALSE}
lapply(cast_ge, function(x) {decorana(x)})
lapply(cast_ge, function(x) {plot(decorana(x), display="both")})
```

Also for genus data, the length of the first axis is > 3 S.D. in all months and therefore, a unimodal gradient can be assumed for all months.

#### Genus - CCA
```{r dca-genus-cca-dataset, echo=TRUE, message=FALSE}
lapply(cast_ge_cca, function(x) {decorana(x)})
lapply(cast_ge_cca, function(x) {plot(decorana(x), display="both")})
```

For genus data for the cca, the length of the first axis is > 4 S.D. in all months and therefore, a unimodal gradient can be assumed for all months.

## CA

Correspondance Analysis (CA) was used to determine the major trends of variation of the diatom community before including any environmental data. CA is an ordination method and hence reduces data of multidimensional space to a 2- or 3-dimensional representation with minimal loss of information. The dimensions included in the ordination plot are the ones with the highest amount of variance and thus display the greatest part of variability of the data. The advantage of CA is that, by using weighted averages ordination, sites and species are ordered at the same time into the same space. In the ordination plot, similar communities and species are close together while dissimilar communities and species are further apart.

### Species

```{r  ca-species, echo=TRUE, message=FALSE}
# conduct CA
ca_sp <-lapply(cast_sp, function(x) {cca(x)})

# Compute summary of CA results to inspect proportion of variance explained by each axis.
lapply(ca_sp, function(x) {summary(x)})
```

```{r  plot-ca-species, echo=TRUE, message=FALSE}
# Compute biplots without names
lapply(cast_sp, function(x) {plot(cca(x), scaling=2)})

# Biplots with species names
dianame_long_sp <- lapply(cast_sp, function(x) colnames(x))

dianame_sp <- lapply(cast_sp, function(x) make.cepnames(names(x)))
stems_sp <- lapply(cast_sp, colSums)

for (i in 1:length(dianame_sp)) {
  plot(ca_sp[[i]], dis="sp", type="n") #red crosses = species, dots = sites
  orditorp(ca_sp[[i]], dis="sp", lab=dianame_sp[[i]], priority=stems_sp[[i]],
           pcol="red", pch="+")
}
```
It seems like there are not one or two main factors explaining the variance in diatom composition but many since the fraction of cumulative explained variation is also not very high when considering several axes.
I.e.
July: cum explained variance of 1.+2. axes:0.12000
August: cum explained variance of 1.+2. axes: 0.09192
September: cum explained variance of 1. + 2. axes: 0.11570

### Genus

```{r  ca-genus, echo=TRUE, message=FALSE}
# conduct CA
ca_ge <-lapply(cast_ge, function(x) {cca(x)})

# Compute summary of CA results to inspect proportion of variance explained by each axis.
lapply(ca_ge, function(x) {summary(x)})
```

The cumulated explained variance of the first two axes is above 20 % in all months which is a much higher value than when taking species for the CA. Therefore, it might make more sense to proceed analysis with genus data instead of with species data.
I.e.: 
July: 1.+2. CA: 19.9 % of cumulative explaned variance
August: 1.+2. CA: 19.8 % of cumulative explaned variance
September:  1.+2. CA: 23.5 % of cumulative explaned variance

```{r  plot-ca-genus, echo=TRUE, message=FALSE}
# Compute biplots without names
lapply(cast_ge, function(x) {plot(cca(x), scaling=2)})

# Biplots with species names
dianame_long_ge <- lapply(cast_ge, function(x) colnames(x))

# dianame_m_ge <- lapply(cast_months_ge, function(x) make.cepnames(names(x)))
stems_ge <- lapply(cast_ge, colSums)

for (i in 1:length(dianame_long_ge)) {
  plot(ca_ge[[i]], dis="sp", type="n") #red crosses = species, dots = sites
  orditorp(ca_ge[[i]], dis="sp", lab=dianame_long_ge[[i]], priority=stems_ge[[i]],
           pcol="red", pch="+")
}

```

Does not work yet
```{r}
# make plots
ca_list_ge = list()
for (i in 1:length(dianame_long_ge)) {
 p = plot(ca_ge[[i]], dis="sp", type="n") 
  orditorp(ca_ge[[i]], dis="sp", lab=dianame_long_ge[[i]], priority=stems_ge[[i]],
           pcol="red", pch="+")
  ca_list_ge[[i]] = p
}

# save plots
for (i in 1:3) {
  file_name = paste("ca_plot_ge_", i, ".png", sep="")
  png(file_name)
  print(ca_list_ge[[i]])
  dev.off()
}
```

## Environmental data

`cast_ge_cca`is the diatom data to use for this part.

All physical-chemical data were deleted that were not taken at the same site and in the same month as a diatom sample.
--> Nochmal neu berechnen wenn weitere Monate rausgeschmissen wurden.
```{r join-phch, echo=TRUE, message=FALSE}
nrow(phch_sam) # 1234777   # 5113250 !
phch_sam <- semi_join(phch_sam, dia_sam_cca, by =c("site_id","month")) 
nrow(phch_sam) # 21695    # 72066 !

```

### Keep only certain environmental variables

```{r envi-variables, echo=TRUE, message=FALSE}
phch_list = phch_sam %>%
  filter(psm == FALSE) %>%
  distinct(name) %>%
  arrange(name)
phch_list #list of all environmental variables that are not herbicides

nrow(phch_sam[phch_sam$name=="Elektrische LeitfÃ¤higkeit (20Â°C)", ]) #2133  # 885
nrow(phch_sam[phch_sam$name=="Elektrische LeitfÃ¤higkeit (25Â°C)", ]) #5034  # 1916
# More data available for conductivity at 25 degree

# o-Phosphat-P,ortho-Phosphat
nrow(phch_sam[phch_sam$name=="o-Phosphat-P", ]) #2391  # 1018
nrow(phch_sam[phch_sam$name=="ortho-Phosphat", ]) #2070 #PO4 3-  # 891
# Is that the same just with a different name? Can I then combine them? if yes --> Just rename one variable to the other

phch_sam <- phch_sam %>%
  filter(psm == 'TRUE' | name %in% c("Wassertemperatur", "pH-Wert (Feld)", "Elektrische LeitfÃ¤higkeit (25Â°C)", "SauerstoffsÃ¤ttigung", "gesamter organisch gebundener Kohlenstoff", "Gesamt-Stickstoff" , "o-Phosphat-P", "ortho-Phosphat" ))

# Rename o-Phosphat-P cells
# phch_sam$name[phch_sam1$name=="o-Phosphat-P"] <- "ortho-Phosphat"

# Rename all names
phch_sam$name[phch_sam$name=="Wassertemperatur"] <- "temperature"
phch_sam$name[phch_sam$name=="pH-Wert (Feld)"] <- "pH"
phch_sam$name[phch_sam$name=="Elektrische LeitfÃ¤higkeit (25Â°C)"] <- "conductivity"
phch_sam$name[phch_sam$name=="SauerstoffsÃ¤ttigung"] <- "oxygen"
phch_sam$name[phch_sam$name=="gesamter organisch gebundener Kohlenstoff"] <- "TOC"
phch_sam$name[phch_sam$name=="Gesamt-Stickstoff"] <- "tot_N"
phch_sam$name[phch_sam$name=="o-Phosphat-P"] <- "o_phosphat_p"
phch_sam$name[phch_sam$name=="ortho-Phosphat"] <- "ortho_phosphat"

nrow(phch_sam) # 10996  # 51429 if herbicides remain in dataset. Keep them!!  
# 36449 !  --> In the beginning, all diatom samples were deleted that were not measured at any site where psm were taken and value_fin was == 0. This results in less phch samples that were taken at a diatom sampling site. This was recalculated and therefore, the numbers have changed.
nrow(phch_sam[phch_sam$psm==TRUE,])  # 26408 datapoints are from herbicide data
```
Which data to use for tot-P??

    - Landwirtschaft (atkis_perc) + not as name and unit yet but as seperate column
    - Temperature +
    - pH +
    - maxTU/Monat (2 wichtigsten Monate)
    - conductivity +
    - Sauerstoffgehalt +
    - tot-P
    - tot-N +
    - TOC +
    

### calculate TU from EC50
TU = log10(concentration of compound / EC50)
Calculate the sumTU and the maxTU per site and date.
```{r Tcalculate-TU, echo=TRUE, message=FALSE}
# Dataset with only psm data
phch_sam_y = phch_sam %>%
  filter(psm == TRUE) %>%
  mutate(TU = log10(value_fin) / ec50f_al4896_fin)
nrow(phch_sam_y) # 7958   # 26408

nrow(phch_sam_y[phch_sam_y$value_fin=="0", ])
# 24023
# Many pesticides have concentration of zero.
# The TU of theses measurements is therefore -infinity and has to be removed.

# remove infinite values
phch_sam_y = phch_sam_y %>%
  filter(!is.infinite(TU)) 
nrow(phch_sam_y)  # 24.4.: 2385 rows remain

# calculate sumTU, maxTU
phch_sam_y_TU = phch_sam_y %>%
  group_by(sample_id, site_id, date) %>%
  summarise(sumTU = sum(TU), maxTU = max(TU), total = n())
# Good dataset of sumTU and maxTU
# --> Needs to be included in phch_sam as variable in name and value column
nrow(phch_sam_y_TU) # 622

#phch_sam_y_TU <- phch_sam_y_TU[ ,phch_sam_y_TU$name]
# column name must be sumTU and maxTU respectively
# column sumTU and max TU must be converted to value_fin
# then:
# phch_sam_bin <- bind_rows(phch_sam, phch_sam_y_TU)
phch_sam_y_maxTU <- phch_sam_y_TU[,-4]
phch_sam_y_sumTU <- phch_sam_y_TU[,-5]
phch_TU_bind <- bind_rows(phch_sam_y_maxTU, phch_sam_y_sumTU)

# create new columns "name" and "value_fin"
# Remove columns sumTU and maxTU and total
phch_TU_bind <- phch_TU_bind %>%
  mutate(name = if_else(is.na(maxTU), "sumTU", "maxTU")) %>%
  mutate(value_fin = if_else(is.na(maxTU), sumTU, maxTU)) %>%
  select(-c(sumTU, maxTU, total))

# Remove single herbicides
phch_sam <- phch_sam[!phch_sam$psm==TRUE, ]

# Bind table with phch_sam table
# does not always work properly..
phch_sam <- bind_rows(phch_sam, phch_TU_bind)


#phch_sam2 = phch_sam %>%
#  filter(! psm == TRUE)
# does not work properly. WHY? Only removes new variables maxTU and sumTU


# Year, month and day column need to be renewed since they do not exist for sumTU and maxTU
phch_sam$year <- format(phch_sam$date, '%Y')  # Create column for year
phch_sam$month <- format(phch_sam$date, '%m') # Create column for month
phch_sam$day <- format(phch_sam$date, '%j')   # Create column for day of the year

nrow(phch_sam)  
unique(phch_sam$name)  #nrow=11365, maxTU, sumTU present. 
# seems to work now
```

Agricultural data.
```{r landuse-to-name-column}
# Join landuse data with diatom dataset . Remove all landuse sites where diatoms haven't been sampled.
nrow(landuse) #1302
landuse = semi_join(landuse, dia_sam_cca, by = "site_id") # does not need to be joined by month since landuse is independent of date
nrow(landuse) # 59

# change column "atkis_perc" to "value_fin"
names(landuse) [names(landuse) =="atkis_perc"] <- "value_fin"

# create column "name" with the entry "agriculture" in all columns
landuse$name <- "agriculture"

# create column "month" with the entry "07" in all columns
landuse$month <- "07"

# make copy of landuse dataset
landuse_09 <- landuse

# change month from 07 to 09
landuse_09$month <- "09"

# Bind landuse and landuse_09
landuse <- bind_rows(landuse, landuse_09)
nrow(landuse) # 118

# Bind landuse table to phch_sam
phch_sam <- bind_rows(phch_sam, landuse)

# List of all environmental variables
phch_list <- phch_sam %>%
  distinct(name) %>%
  arrange(name)
phch_list

nrow(phch_sam)  # 11483

# nrow(phch_sam[phch_sam$name=="agriculture" ,] )
#phch_sam <- phch_sam[!phch_sam$name=="agriculture" ,] 
```


Join phch_sam on dia_sam_cca by site_id to exclude all samples that were not taken at a diatom sampling site.

Also join dia_sam_cca on phch_sam by site_id to exclude all diatom samples were no phys-chem parameters were taken. --> does not need to be performed
```{r}
nrow(phch_sam) # 11483
phch_sam <- semi_join(phch_sam, dia_sam_cca, by =c("site_id","month"))
nrow(phch_sam) # 11425
# normally, this step should not have to be needed. Where does the gap come from?

nrow(dia_sam_cca) # 13437
length(unique(dia_sam_cca$site_id)) #228
length(unique(phch_sam$site_id))    #228
length(unique(phch_sam$site_id)) 

####### these steps dont have to be performed ########
dia_sam_cca1 <- semi_join(dia_sam_cca, phch_sam[phch_sam$name=="maxTU" | phch_sam$name=="sumTU" ,], by = c("site_id", "month"))
nrow(dia_sam_cca1)  # 13437  
# no dia_sam_cca samples have to be excluded because they were not sampled at a site where herbicides were measured

dia_sam_cca2 <- semi_join(dia_sam_cca, phch_sam, by = c("site_id", "month"))
nrow(dia_sam_cca2) # 13437
# at all diatom sampling sites, some phch_samples were taken
```


How many negative values are in value_fin? Can CCA handle negative values?
```{r}
nrow(phch_sam[phch_sam$value_fin<0 ,]) # 1310
phch_sam[phch_sam$value_fin<0 ,] # Many maxTU (and sumTU?) values are below zero.
nrow(phch_sam[phch_sam$value_fin==0 ,]) # 260
```


Aggregate environmental data over all years for July and September. Then, transform form long to wide format.
```{r cast-envi, echo=TRUE, message=FALSE}
phch_sam_aggr <- phch_sam %>% 
  group_by(month, name, site_id) %>%
  summarise(mean = mean(value_fin),
            perc95 = quantile(value_fin, 0.95, na.rm = TRUE),
            total = n()) %>%
  arrange(name)

# Store single months as seperate elements of a list
phch_sam_list <- split(phch_sam_aggr, phch_sam_aggr$month)

cast_envi <- lapply(phch_sam_list, function(x) dcast(x, site_id ~ name, value.var="perc95", fill = 0))

# Take the first column and store it as a rowname, afterwards, delete the first column.
cast_envi  <- lapply(cast_envi ,
                     function(x) { rownames(x) <- x[,1];
                                   x[,1] <- NULL;
                                   x })

# Remove rows where the row sum is zero.
cast_envi  <- lapply(cast_envi ,
       function(x) { x[rowSums(x) != 0,] })

```

### state as variable
```{r state-as-variable}
# create loop/lapply function to shorten skript

# Create variable for state
phch_siteid_07 <- phch_sam %>%
  filter(month=="07") %>% 
  distinct(site_id, .keep_all = TRUE)

phch_siteid_09 <- phch_sam %>%
  filter(month=="09") %>% 
  distinct(site_id, .keep_all = TRUE)

# Dataset with only site_id and state as anew variable
phch_sam_state_07 <- phch_siteid_07 %>%
  mutate(state = sub('_.*$','', phch_siteid_07$site_id)) %>%
  select(site_id, state)

phch_sam_state_09 <- phch_siteid_09 %>%
  mutate(state = sub('_.*$','', phch_siteid_09$site_id)) %>%
  select(site_id, state)
# mutate matches the pattern i.e. first occurence of _ to the end of the string and replace with ''

phch_sam_state_07$state <- as.factor(phch_sam_state_07$state)
phch_sam_state_09$state <- as.factor(phch_sam_state_09$state)

# Set site_id as rownames
rownames(phch_sam_state_07) <- phch_sam_state_07$site_id
phch_sam_state_07$site_id <- NULL

rownames(phch_sam_state_09) <- phch_sam_state_09$site_id
phch_sam_state_09$site_id <- NULL

# Bind new column to table
cast_envi_1 <- cbind(cast_envi[[1]], NewColumn=phch_sam_state_07)
cast_envi_2 <- cbind(cast_envi[[2]], NewColumn=phch_sam_state_09)

# Combine both tables to recreate cast_envi list
cast_envi <- list(cast_envi_1, cast_envi_2)

# Rename list elements
names(cast_envi) <- c("07", "09")

# Do binding to both list elements:
#cast_envi_trial <- for (i in 1:length(cast_envi)) {
#  cbind(cast_envi[[i]], phch_sam_state[[i]])
#}
# Does not work, empty output
```

Save final datasets
```{r save-final-psm-datasets}
#saveRDS(cast_envi, file.path('cache', 'psm_final.rds'))
cast_envi <- readRDS(file.path('cache', 'psm_final.rds'))

cast_ge_cca <- readRDS(file.path('cache', 'dia_ge_final.rds'))
```

### Collinearity
```{r}
# Create dataset without variable "state" since it cannot be used during calculation of correlation
cast_envib <- lapply(cast_envi, function(x) { x["state"] <- NULL; x })

# Calculate correlations between variables
lapply(cast_envib, function(x) {cor(x, use = "complete.obs")})

```
Correlations
maxTU & sumTU: 
July: 0.87230938
September: 0.999956837

o_phosphate_p & ortho_phosphat: 
July: 0.60779726
September: 0.46383438

--> sumTU or maxTU must be excluded!

For July, sumTU and maxTU both remain in the dataset and further variable selection will be based on forward selection. For September, only maxTU will remain in the dataset.According to (@Schafer.2013), there is not a great difference between the results of sumTU and maxTU, but in agricultural regions, the toxic effects are mainly driven by a single compound and therefor, maxTU will remain in the dataset although it seems like in this dataset, maxTU and sumTU are so highly correlated, the selection of either one of the variables would not make a big difference.

```{r remove-sumtu-from-july}
cast_envi[[2]][["sumTU"]] <- NULL
```


### Try out CCA
```{r cca}
## July
names(cast_envi[["07"]])

dia_cca_07 <- cca(cast_ge_cca[["07"]] ~ agriculture + conductivity + maxTU + o_phosphat_p + ortho_phosphat + oxygen + pH + sumTU + temperature + TOC + tot_N + state, cast_envi[["07"]])
dia_cca_07

# Plot
windows()
plot_cca_07 <- plot(dia_cca_07, main = "CCA July")
savePlot(filename="figures/plot_cca_07", type="png")

## September
dia_cca_09 <- cca(cast_ge_cca[["09"]] ~ agriculture + conductivity + maxTU + o_phosphat_p + ortho_phosphat + oxygen + pH + temperature + TOC + tot_N + state, cast_envi[["09"]])
dia_cca_09

# Plot
plot_cca_09 <- plot(dia_cca_09, main = "CCA September")
savePlot(filename="figures/plot_cca_09", type="png")
dev.off()


cca_list <- list(dia_cca_07, dia_cca_09)

#the arrow points to the direction
#of the gradient, and its length indicates the strength of the variable

# Combine both months with for loop
# Does not work yet, no output...

#for (i in 1:length(cast_ge_cca)) {
#  cca(cast_ge_cca[[i]] ~ agriculture + conductivity + maxTU + o_phosphat_p + ortho_phosphat + oxygen + pH #+ sumTU + temperature + TOC + tot_N, cast_envi[[i]])
#}
```
The (unadjusted ???)explained (i.e. constrained) inertia of the July CCA is 14.75 % and of the September CCA it is 13.49 %.

With state variable: explained intertia of July CCA is 18.53 % (17.46 ??) and of the September CCA it s 15.74 %.

### VIF
```{r vif}
lapply(cca_list, function(x) vif.cca(x))
#lapply(cca_list_pars, function(x) vif.cca(x))
```
VIF = 1 (Not correlated)
1 < VIF < 5 (Moderately correlated)
VIF >=5 (Highly correlated)


State variables have high variance inflation factors but since variable is a factor, I will ignore this. 
July: SumTU and maxTU have VIFs of 4.525703 and 4.518743, respectively, which is still okay. All other VIFs are below 4.

## Permutation tests in CCA, forwards selection and parsimonious CCA 
pp. 205 Numerical Ecology with R

Test for significans of CCA results by permutations
```{r permutation-test-of-cca-results}
# Permutation test of the overall analysis
lapply(cca_list, function(x) {anova(x, step = 1000)})

# Permutation test of each axis
lapply(cca_list, function(x) {anova(x, by="axis", step = 1000)})
```
The permutation test of the overall analysis indicates a significant model for the month Jula (p = 0.019) and a very significant model for the month September (p = 0.01).

The permutation test for each axis indicates a significant first axis (p = 0.024) for July. For the CCA for September, also only the first axis was significant (p = 0.019).

--> Exact values will change every time because different steps wil be performed, model is compared to different random models.

### Forward selection of variables
```{r forward-selection}
for (i in 1:length(cast_ge_cca)) {
  ordistep(cca(cast_ge_cca[[i]]~1, data = cast_envi[[i]]), scope = formula(cca_list[[i]]), direction = "forward", pstep = 1000)
}

```
July: cast_ge_cca[[i]] ~ ortho_phosphat + oxygen 
is the most parsimonious model.

September: cast_ge_cca[[i]] ~ ortho_phosphat + conductivity + TOC 

```{r parsimonious-cca}
# July
dia_cca_pars_07 <- cca(cast_ge_cca[["07"]] ~ ortho_phosphat + oxygen, cast_envi[["07"]])
dia_cca_pars_07

# September
dia_cca_pars_09 <- cca(cast_ge_cca[["09"]] ~ ortho_phosphat + + conductivity + TOC, cast_envi[["09"]])
dia_cca_pars_09

# Bind both CCAs to one list
cca_list_pars <- list (dia_cca_pars_07, dia_cca_pars_09)

# Summary of both CCAs
lapply(cca_list_pars, function(x) summary())
# Last element: Find out position of state variables in plot to known which x belongs to which state.


# Permutation test of the overall analysis
lapply(cca_list_pars, function(x) {anova(x, step = 1000)})

# Permutation test of each axis
lapply(cca_list_pars, function(x) {anova(x, by="axis", step = 1000)})
```
The explained (i.e. constrained) inertia of the July CCA was 18.53 % and of the September CCA it was 16.34 %. The explained inertia of the parsimonious CCAs was 6.8 % for July and 6.8 % for Septmeber.This drop is compensated by a clearer model with two significant canonical axes instead of one for both months.

The parsimonious CCA for July and September were both highly significant (p = 0.001)
The permutation test for each axis indicated that both axes of the July CCA were significant (p = 0.002 and 0.003). The permutation test for the September CCA indicates that the first 2 axes were significant ( p = 0.001 and 0.007). 

```{r plot-parsimonious-CCA}
windows()
plot_cca_pars_07 <-plot(dia_cca_pars_07, main = "parsimonious CCA July")
identify(plot_cca_pars_07, what="species")  # manually assign which species should be shown
#identify(plot_cca_pars_07, what="sites")    # sites
savePlot(filename="figures/plot_cca_pars_07", type="png")

plot_cca_pars_09 <-plot(dia_cca_pars_09, main = "parsimonious CCA September")
identify(plot_cca_pars_09, what="species")  # manually assign which species should be shown
#identify(plot_cca_pars_09, what="sites")    # sites
savePlot(filename="figures/plot_cca_pars_09", type="png")
# dev.off() # R session terminates when using this command. Do it manually instead.
```
