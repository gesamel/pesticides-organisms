---
title: "Untitled"
author: "Gesa Amelung"
date: "7 November 2017"
output:
  pdf_document: default
  html_document: default
bibliography: rpc_lit.bib
editor_options: 
  chunk_output_type: console
  
---

# Data Analysis

## Setup

The following packages and the data base access script was loaded.

```{r setup, echo=TRUE, message=FALSE}
## load packages
require(RPostgreSQL)
require(sf)
require(knitr)
require(mapview)
require(data.table)
require(dplyr)
require(vegan)
require(ggplot2)
require(gridExtra)
require(stringr)
require(polycor)

## switch
online = FALSE

## load access data
path = getwd()
source(file.path(path, 'amelung_access.R'))
```

## Loading data

### Pesticide data

The pesticide data was loaded including the samples, the sites and geographic information of the sites.

```{r load-PSM-data, echo=TRUE, eval=FALSE, message=FALSE}
if (online) {
  drv = dbDriver("PostgreSQL")
  con = dbConnect(drv, dbname = DBname, user = DBuser, host = DBhost, port = DBport, password = DBpassword)
  
  psm_sites_geo = st_read_db(con, query = "SELECT *
                                           FROM views.psm_sites_2005")
  psm_sites = as.data.frame(psm_sites_geo)
  psm_sam = dbGetQuery(con, "SELECT *
                                 FROM views.psm_samples_2005 sam
                                 JOIN phch.phch_variables var
                                ON var.variable_id = sam.variable_id")
  psm_sam = psm_sam[ ,-c(16, 24)] # delete duplicate rows
  
  dbDisconnect(con)
  dbUnloadDriver(drv)
  
  saveRDS(psm_sites_geo, file.path('cache', 'psm_sites_geo.rds'))
  saveRDS(psm_sites, file.path('cache', 'psm_sites.rds'))
  saveRDS(psm_sam, file.path('cache', 'psm_sam.rds'))
} else {
  psm_sites_geo <- readRDS(file.path('cache', 'psm_sites_geo.rds'))
  psm_sites <- readRDS(file.path('cache', 'psm_sites.rds'))
  psm_sam <- readRDS(file.path('cache', 'psm_sam.rds'))
}

psm_sam = psm_sam %>%
  filter(psm_type == 'herbicide' & date > '2004-12-31')
## AS: when the script is finished we could also consider applying it to all pesticides

# Create column for year
psm_sam$year <- format(psm_sam$date, '%Y')
psm_sam$month <- format(psm_sam$date, '%m')
psm_sam$day <- format(psm_sam$date, '%j')
```

### Diatom data
```{r load-diatom-data, echo=TRUE, message=FALSE}
if (online) {
  drv = dbDriver("PostgreSQL")
  con = dbConnect(drv, dbname = DBname, user = DBuser, host = DBhost, port = DBport, password = DBpassword)
  # dia_sites = dbGetQuery(con, "SELECT * FROM dia.dia_sites") ##AS: no need to extra load this
  dia_sites_geo = st_read_db(con, query = "SELECT * FROM dia.dia_sites")
  dia_sites = as.data.frame(dia_sites_geo)
  dia_sam = dbGetQuery(con, "SELECT *
                         FROM dia.dia_samples
                         WHERE date > '2004-12-31'
                         ")
  dbDisconnect(con) 
  dbUnloadDriver(drv)
  
  saveRDS(dia_sites_geo, file.path('cache', 'dia_sites_geo.rds'))
  saveRDS(dia_sites, file.path('cache', 'dia_sites.rds'))
  saveRDS(dia_sam, file.path('cache', 'dia_sam.rds'))

} else {
  
  dia_sites_geo = readRDS(file.path('cache', 'dia_sites_geo.rds'))
  dia_sites = readRDS(file.path('cache', 'dia_sites.rds'))
  dia_sam = readRDS(file.path('cache', 'dia_sam.rds'))
}

# Create column for species name only. Add "sp." to those names that only have genera 
dia_sam$species <- gsub('[[:punct:]]', '', dia_sam$taxon) # remove punctuation characters
dia_sam$species <- gsub('([a-z]+)\\s([a-z]+)(.+)*', '\\1 \\2', dia_sam$species) # reduce to two strings (removes: 'var', 'form')
dia_sam$species <- ifelse(str_count(dia_sam$species, pattern = '\\s') == 0,
                          paste0(dia_sam$species, ' sp.'),
                          dia_sam$species)

# table(str_count(dia_sam$species, pattern = '\\s')) # count space characters (only 1s should be left) ##AS: tests for two name taxa

# Create column for genus name
dia_sam$genus <- sub("^(\\S*).*", "\\1", dia_sam$taxon)

# Create column for year
dia_sam$year <- format(dia_sam$date, '%Y')
dia_sam$month <- format(dia_sam$date, '%m')
dia_sam$day <- format(dia_sam$date, '%j')
```

### River network
```{r load-river-network}
if (online) {
  drv = dbDriver("PostgreSQL")
  con = dbConnect(drv, dbname = DBname, user = DBuser, host = DBhost, port = DBport, password = DBpassword)
  
  streams = st_read_db(con, query = "SELECT * FROM spatial.gewaessertyp")
  
  dbDisconnect(con)
  dbUnloadDriver(drv)
  
  saveRDS(streams, file.path('cache', 'streams.rds'))

} else {
  
  streams = readRDS(file.path('cache', 'streams.rds'))
}
```

### Load physical-chemical data
```{r load-phch-data, echo=TRUE, message=FALSE}
if (online) {
  drv = dbDriver("PostgreSQL")
  con = dbConnect(drv, dbname = DBname, user = DBuser, host = DBhost, port = DBport, password = DBpassword)

  phch_sam = dbGetQuery(con, "SELECT *
                              FROM phch.phch_samples sam
                              LEFT JOIN phch.phch_variables var ON var.variable_id = sam.variable_id
                                  WHERE date > '2004-12-31' AND date < '2016-01-01'")
  dbDisconnect(con)
  dbUnloadDriver(drv)
  
  saveRDS(phch_sam, file.path('cache', 'phch_sam.rds'))
} else {
  phch_sam = readRDS(file.path('cache', 'phch_sam.rds'))
}

phch_sam = phch_sam[ , -c(16, 24)] # removes duplicated unit, variable_id entries

# Get only data that are not psm or psm = herbicide
#phch_sam <- phch_sam[phch_sam$psm_type%in%c("herbicide", ""),] # 9,620,631 datapoints
# get onlly data that are no chemicals or are herbicides.
phch_sam <- phch_sam %>%
  filter(casnr =="" | psm_type=="herbicide")
# 5,268,995 datapoints
nrow(phch_sam[phch_sam$casnr=="",])

phch_sam$year <- format(phch_sam$date, '%Y')  # Create column for year
phch_sam$month <- format(phch_sam$date, '%m') # Create column for month
phch_sam$day <- format(phch_sam$date, '%j')   # Create column for day of the year

```

### Load ec50 data

```{r load-ec50-data, echo=TRUE, message=FALSE}
if (online) {
  drv = dbDriver("PostgreSQL")
  con = dbConnect(drv, dbname = DBname, user = DBuser, host = DBhost, port = DBport, password = DBpassword)

ec50 = dbGetQuery(con, "SELECT casnr, subst_name, ec50f_al4896_fin
                                FROM phch.phch_ec50_fin
                  ")
  dbDisconnect(con)
  dbUnloadDriver(drv)
  
  saveRDS(ec50, file.path('cache', 'ec50.rds'))
} else {
  ec50 = readRDS(file.path('cache', 'ec50.rds'))
}
```

### Load landuse data

```{r load-landuse-data, echo=TRUE, message=FALSE}
if (online) {
  drv = dbDriver("PostgreSQL")
  con = dbConnect(drv, dbname = DBname, user = DBuser, host = DBhost, port = DBport, password = DBpassword)

landuse = dbGetQuery(con, "SELECT site_id, atkis_perc
                                FROM spatial_derived.land_use_ezg30
                  ")
  dbDisconnect(con)
  dbUnloadDriver(drv)
  
  saveRDS(landuse, file.path('cache', 'landuse.rds'))
} else {
  landuse = readRDS(file.path('cache', 'landuse.rds'))
}
```

Join physical-chemical data with EC50 data.
```{r join-ec50}
# Join phch with ec50 to include casnr
phch_sam = left_join(phch_sam, ec50, by = "casnr")

# Remove all rows that are pesticides but don't have a ec50f_al4896_fin  entry
# Keep all rows that have a EC50 value or that are no pesticides.

phch_sam = phch_sam %>%
  filter(!ec50f_al4896_fin=="" | psm == FALSE)

```


## Data preparation

For the CCA later on, a dataset was created containing only diatom samples where herbicides were measured at the same site in the same month (`dia_sam_cca`). For the CA, all samples were retained in order to have a larger dataset  (`dia_sam`).

```{r join-on-site-year, echo=TRUE, message=FALSE}
# Diatom data
dia_sam_cca <- semi_join(dia_sam, phch_sam[phch_sam$psm==TRUE & !phch_sam$value_fin == 0,], by = c("site_id", "month"))

```


### Usage of cover data as quantitative variable
In most cases, diatom cover was measured instead of abundance. Therefore, rows where abundance was measured were deleted. Instead, the cover data is used as the quantitative variable in the following analyses. The deletion of irrelevant rows was performed for the datasets for CA and CCA seperately.

```{r delete-abundance-data, echo=TRUE, message=FALSE}
dia_sam <- dia_sam[!is.na(dia_sam$cover), ]
dia_sam <- dia_sam[,-6]    #delete column with abundance data

dia_sam_cca <- dia_sam_cca[!is.na(dia_sam_cca$cover), ]
dia_sam_cca <- dia_sam_cca[,-6] 
```

## Visualization of the sampling frequency

Sampling days and sampling events per year.

```{r sampling-days-per-year, echo=TRUE, message=FALSE}
## Number of samples

# Count number of samples per month and year
sample_count_ym = dia_sam %>%
  group_by(year, month) %>%
  summarise(N = n()) %>%
   as.data.frame()

# Count number of samples per year
sample_count_y = dia_sam %>%
  group_by(year) %>%
  summarise(N = n()) %>%
   as.data.frame()

## Number of sampling events

# Count number of sampling events (id_pn) per year
event_count_y <- dia_sam %>% 
  group_by(year) %>%
  summarise(N = n_distinct(id_pn))  %>%
   as.data.frame()

# Count number of sampling events per month and year
event_count_ym <- dia_sam %>% 
  group_by(year, month) %>%
  summarise(N = n_distinct(id_pn))  %>%
   as.data.frame()

## Plots

# Plot: Number of samples per month and year
gg1 <- ggplot(sample_count_ym, aes(y = N, x = month)) +
  geom_point() +
  facet_wrap( ~ year) +
  ggtitle ("number of diatom samples per month and year")
gg1

# Plot: Number of sampling events per month and year
gg2 <- ggplot(event_count_ym, aes(y = N, x = month)) +
  geom_point() +
  facet_wrap( ~ year) +
  ggtitle ("number of diatom sampling events per month and year")
gg2

## Plot: Sampling counts per year & Event counts per year
gg3 <- ggplot(dia_sam, aes(x=year)) +
  geom_bar() +
  labs(title="diatom samples per year", x = "year", y = "sample counts")

gg4 <- ggplot(event_count_y, aes(x=year, y = N)) +
  geom_bar(stat="identity") +
  labs(title="events per year", x = "year", y = "event counts")

grid.arrange(gg3, gg4, ncol=2)

# number of samples per month
gg5 <- ggplot(dia_sam, aes(x=month)) +
  geom_bar() +
  labs(title="diatom samples per month", x = "month", y = "number of samples")
gg5
ggsave(gg5, width = 4, height = 4, filename = "figures/n_month.png")

# number of samples per month and year
gg6 <- ggplot(sample_count_ym, aes(y = N, x = year)) +
  geom_point() +
  facet_wrap( ~ month) +
  ggtitle ("number of diatom samples per year and month")
gg6
ggsave(gg6, width = 10, height = 10, filename = "figures/n_my.png")

sam_ym <- dcast(sample_count_ym, year ~ month, fill = "-")

# number of sampes per day
gg07 <- ggplot(dia_sam[dia_sam$month=="07",], aes(x=day)) +
  geom_bar() +
  ylim(0, 1750) +
  labs(title="diatom samples per day - July", x = "day", y = "number of samples")

gg08 <- ggplot(dia_sam[dia_sam$month=="08",], aes(x=day)) +
  geom_bar() +
  ylim(0, 1750) +
  labs(title="diatom samples per day - August", x = "day", y = "number of samples")

gg09 <- ggplot(dia_sam[dia_sam$month=="09",], aes(x=day)) +
  geom_bar() +
  ylim(0, 1750) +
  labs(title="diatom samples per day - September", x = "day", y = "number of samples")

gg7 <- grid.arrange(gg07, gg08, gg09, ncol=3)
ggsave(gg7, width = 22, height = 10, filename = "figures/n_july_sept.png")

```

It seems like the distribution of samples and sampling events is very similar. This means that on every sampling day and event, a similar number of samples was taken. 

One month of the early and the late application season, respectively, were to be chosen for further analysis. Even though most samples were available for the month August, to compare July and September seemed more suitable. 

```{r herbicides-sampling-overview, echo=TRUE, message=FALSE}
psm_count_ym = phch_sam %>%
  filter(psm == TRUE) %>%
  group_by(year, month) %>%
  summarise(N = n()) %>%
   as.data.frame()

psm_gg1 <- ggplot(phch_sam[phch_sam$psm==TRUE,], aes(x=month)) +
  geom_bar() +
  labs(title="herbicide samples per month", x = "month", y = "number of samples")
psm_gg1
ggsave(psm_gg1, width = 4, height = 4, filename = "figures/n_psm_month.png")

psm_gg2<- ggplot(psm_count_ym, aes(y = N, x = year)) +
  geom_point() +
  facet_wrap( ~ month) +
  ggtitle ("number of herbicide samples per year and month")
psm_gg2
ggsave(psm_gg2, width = 10, height = 10, filename = "figures/n_psm_my.png")

psm_gg3 <- ggplot(phch_sam[phch_sam$psm==TRUE,], aes(x=year)) +
  geom_bar() +
  labs(title="herbicide samples per year", x = "year", y = "sample counts")
psm_gg3
```

Herbicides were sampled in all month with a high intensity. Generally, less samples were taken in the winter months. According to this continuous high amount of data, no months have to be excluded based on that. The amount of diatom data would be the more conservative proxy to gudge which months are appropriate to use for further analyses.
In 2015, almost no herbicide samples were taken. Also, the year 2014 was not so frequently sampled.

```{r remove-months}
dia_sam = dia_sam %>%
  filter(month %in% c("07",  "09"))

dia_sam_cca = dia_sam_cca %>%
  filter(month %in% c("07", "09"))
  
```

## Taxon frequency

Removal of rare taxa
```{r  delete-rare-taxa, echo=TRUE, message=FALSE}
## Rare = taxa that occur at less than 5 % of the samples
sampleN = length(unique(dia_sam$id_pn))
n_sp <- length(unique(dia_sam$species))
n_ge <- length(unique(dia_sam$genus))

## Rare genera
dia_sam_ge = dia_sam %>%
  group_by(genus) %>%
  mutate(perc = n_distinct(id_pn) / sampleN) %>%
  arrange(-perc) %>%
  filter(perc >= 0.05)

# precentage of genera remaining after removal of rare genera
n_ge_abu <-length(unique(dia_sam_ge$genus)) #44
n_ge_abu
n_ge_abu/n_ge*100 # 57.1 %

# Plot
dia_sam_N_ge = dia_sam_ge %>%
       group_by(genus) %>%
       summarise(N=n())
plot(density(dia_sam_N_ge$N), main="Genus density")
# Histogram

## Rare species
dia_sam_sp = dia_sam %>%
  group_by(species) %>%
  mutate(perc = n_distinct(id_pn) / sampleN) %>%
  arrange(-perc) %>%
  filter(perc >= 0.05)

# precentage of genera remaining after removal of rare genera
n_sp_abu <-length(unique(dia_sam_sp$species)) # 153
n_sp_abu
n_sp_abu/n_sp*100 # 17.7 %

# Plot
dia_sam_N_sp = dia_sam_sp %>%
       group_by(species) %>%
       summarise(N=n())
plot(density(dia_sam_N_sp$N), main="Species density")

## Rare genera of dia_sam_cca dataset
sampleN_cca = length(unique(dia_sam_cca$id_pn))
n_ge_cca <- length(unique(dia_sam_cca$genus))

## Rare genera
dia_sam_ge_cca = dia_sam_cca %>%
  group_by(genus) %>%
  mutate(perc = n_distinct(id_pn) / sampleN_cca) %>%
  arrange(-perc) %>%
  filter(perc >= 0.05)

# precentage of genera remaining after removal of rare genera
n_ge_abu_cca <-length(unique(dia_sam_ge_cca$genus)) #43
n_ge_abu_cca
n_ge_abu_cca/n_ge_cca*100 # 59.7 %

# Plot
dia_sam_N_ge_cca = dia_sam_ge_cca %>%
       group_by(genus) %>%
       summarise(N=n())
plot(density(dia_sam_N_ge_cca$N), main="Genus density")

```

```{r explore diatom-data}
# min and max values of cover
range(dia_sam_ge$cover)
# count cases for each cover class
cov <- table(unlist(dia_sam_ge$cover))
# barplot of the cover distribution
barplot(cov, las=1, xlab ="cover class", ylab="frequency")
# Number of zero cover
sum(dia_sam_ge$cover==0)

# Species occurences: Numver of sampling dates where each species is present


#--> continue with numerical ecology with R
```


## Transform data to get from long to wide data

For the subsequent analysis, the data needed to be transformend from long to wide format. If several combinations of (`site_id`)  and (`species`) were present, the 95th percentile was taken to aggregate them. Further, the first column was stored as rowname.

#### graphical inspection of years
```{r ggplot-year}
# overview plots

length(unique(dia_sam$site_id)) ##AS: 1194

gr1 = ggplot(dia_sam, aes(y = site_id, x = month)) +
  geom_raster(aes(fill = year)) +
  facet_wrap( ~ year)
gr1

ggsave(gr1, width = 8, height = 5, filename = '/tmp/dia_sam.png')

gr2 = ggplot(dia_cov, aes(y = site_id, x = year)) +
  geom_raster(aes(fill = log10(cover+1)))
gr2
##AS: Maybe skip 2013/14?

gr3 = ggplot(dia_cov) +
  geom_raster(aes(y = site_id, x = day, fill = year))
gr3
```

### Aggregation per month

The data were aggregated per month by the 95th percentile of the cover. The data were then transformed from long to wide format.

#### Species

```{r cast-species, echo=TRUE, message=FALSE}
dia_aggr_sp <- dia_sam_sp %>% 
  group_by(month, species, site_id) %>%
  summarise(mean = mean(cover),
            perc95 = quantile(cover, 0.95, na.rm = TRUE),
            total = n()) %>%
  arrange(species)

# Store single years as seperate elements of a list
dia_aggr_split_sp <- split(dia_aggr_sp, dia_aggr_sp$month)

cast_sp <- lapply(dia_aggr_split_sp, function(x) dcast(x, site_id ~ species, value.var="perc95", fill = 0))

# Take the first column and store it as a rowname, afterwards, delete the first column.
cast_sp <- lapply(cast_sp,
                     function(x) { rownames(x) <- x[,1];
                                   x[,1] <- NULL;
                                   x })

# Remove rows where the row sum is zero.
cast_sp <- lapply(cast_sp,
       function(x) { x[rowSums(x) > 0,] })
```

#### Genus

```{r cast-genus, echo=TRUE, message=FALSE}
dia_aggr_ge <- dia_sam_ge %>% 
  group_by(month, genus, site_id) %>%
  summarise(mean = mean(cover),
            perc95 = quantile(cover, 0.95, na.rm = TRUE),
            total = n()) %>%
  arrange(genus)

# Store single months as seperate elements of a list
dia_aggr_split_ge <- split(dia_aggr_ge, dia_aggr_ge$month)

cast_ge <- lapply(dia_aggr_split_ge, function(x) dcast(x, site_id ~ genus, value.var="perc95", fill = 0))

# Take the first column and store it as a rowname, afterwards, delete the first column.
cast_ge <- lapply(cast_ge,
                     function(x) { rownames(x) <- x[,1];
                                   x[,1] <- NULL;
                                   x })

# Remove rows where the row sum is zero.
cast_ge <- lapply(cast_ge,
       function(x) { x[rowSums(x) > 0,] })
```

#### Genus - CCA dataset

```{r cast-genus-cca, echo=TRUE, message=FALSE}
dia_aggr_ge_cca <- dia_sam_ge_cca %>% 
  group_by(month, genus, site_id) %>%
  summarise(mean = mean(cover),
            perc95 = quantile(cover, 0.95, na.rm = TRUE),
            total = n()) %>%
  arrange(genus)

# Store single months as seperate elements of a list
dia_aggr_split_ge_cca <- split(dia_aggr_ge_cca, dia_aggr_ge_cca$month)

cast_ge_cca <- lapply(dia_aggr_split_ge_cca, function(x) dcast(x, site_id ~ genus, value.var="perc95", fill = 0))

# Take the first column and store it as a rowname, afterwards, delete the first column.
cast_ge_cca <- lapply(cast_ge_cca,
                     function(x) { rownames(x) <- x[,1];
                                   x[,1] <- NULL;
                                   x })

# Remove rows where the row sum is zero.
cast_ge_cca <- lapply(cast_ge_cca,
       function(x) { x[rowSums(x) > 0,] })
```

```{r save-final-psm-datasets}

#saveRDS(cast_ge_cca, file.path('cache', 'dia_ge_final.rds'))
cast_ge_cca <- readRDS(file.path('cache', 'dia_ge_final.rds'))
                         
```

### DCA

Gradient length
#### Species

```{r dca-species, echo=TRUE, message=FALSE}
lapply(cast_sp, function(x) {decorana(x)})
lapply(cast_sp, function(x) {plot(decorana(x), display="both")})
```
The legth of the first axis is > 3 S.D. in all months and therefore, a unimodal gradient can be assumed for all months.

#### Genus
```{r dca-genus, echo=TRUE, message=FALSE}
lapply(cast_ge, function(x) {decorana(x)})
lapply(cast_ge, function(x) {plot(decorana(x), display="both")})
```

Also for genus data, the length of the first axis is > 3 S.D. in all months and therefore, a unimodal gradient can be assumed for all months.

#### Genus - CCA
```{r dca-genus-cca-dataset, echo=TRUE, message=FALSE}
lapply(cast_ge_cca, function(x) {decorana(x)})
lapply(cast_ge_cca, function(x) {plot(decorana(x), display="both")})
```

For genus data for the cca, the length of the first axis is > 4 S.D. in all months and therefore, a unimodal gradient can be assumed for all months.

## CA

### Species

```{r  ca-species, echo=TRUE, message=FALSE}
# conduct CA
ca_sp <-lapply(cast_sp, function(x) {cca(x)})

# Compute summary of CA results to inspect proportion of variance explained by each axis.
lapply(ca_sp, function(x) {summary(x)})
```

```{r  plot-ca-species, echo=TRUE, message=FALSE}
# Compute biplots without names
lapply(cast_sp, function(x) {plot(cca(x), scaling=2)})

# Biplots with species names
dianame_long_sp <- lapply(cast_sp, function(x) colnames(x))

dianame_sp <- lapply(cast_sp, function(x) make.cepnames(names(x)))
stems_sp <- lapply(cast_sp, colSums)

for (i in 1:length(dianame_sp)) {
  plot(ca_sp[[i]], dis="sp", type="n") #red crosses = species, dots = sites
  orditorp(ca_sp[[i]], dis="sp", lab=dianame_sp[[i]], priority=stems_sp[[i]],
           pcol="red", pch="+")
}
```

### Genus

```{r  ca-genus, echo=TRUE, message=FALSE}
# conduct CA
ca_ge <-lapply(cast_ge, function(x) {cca(x)})

# Compute summary of CA results to inspect proportion of variance explained by each axis.
lapply(ca_ge, function(x) {summary(x)})
```

```{r  plot-ca-genus, echo=TRUE, message=FALSE}
# Compute biplots without names
lapply(cast_ge, function(x) {plot(cca(x), scaling=2)})

# Biplots with species names
dianame_long_ge <- lapply(cast_ge, function(x) colnames(x))

# dianame_m_ge <- lapply(cast_months_ge, function(x) make.cepnames(names(x)))
stems_ge <- lapply(cast_ge, colSums)

for (i in 1:length(dianame_long_ge)) {
  plot(ca_ge[[i]], dis="sp", type="n") #red crosses = species, dots = sites
  orditorp(ca_ge[[i]], dis="sp", lab=dianame_long_ge[[i]], priority=stems_ge[[i]],
           pcol="red", pch="+")
}

```

Does not work yet
```{r}
# make plots
ca_list_ge = list()
for (i in 1:length(dianame_long_ge)) {
 p = plot(ca_ge[[i]], dis="sp", type="n") 
  orditorp(ca_ge[[i]], dis="sp", lab=dianame_long_ge[[i]], priority=stems_ge[[i]],
           pcol="red", pch="+")
  ca_list_ge[[i]] = p
}

# save plots
for (i in 1:3) {
  file_name = paste("ca_plot_ge_", i, ".png", sep="")
  png(file_name)
  print(ca_list_ge[[i]])
  dev.off()
}
```

## Environmental data

`cast_ge_cca`is the diatom data to use for this part.

All physical-chemical data were deleted that were not taken at the same site and in the same month as a diatom sample.
```{r join-phch, echo=TRUE, message=FALSE}
phch_sam <- semi_join(phch_sam, dia_sam_cca, by =c("site_id","month")) 
```

### Keep only certain environmental variables

```{r envi-variables, echo=TRUE, message=FALSE}
phch_list_all = phch_sam %>%
  filter(psm == FALSE) %>%
  distinct(name) %>%
  arrange(name)
phch_list_all #list of all non-psm environmental variables

# Conductivity
nrow(phch_sam[phch_sam$name=="Elektrische LeitfÃ¤higkeit (20Â°C)", ]) # 885
nrow(phch_sam[phch_sam$name=="Elektrische LeitfÃ¤higkeit (25Â°C)", ]) # 1916
# More data available for conductivity at 25 degree

# o-Phosphat-P,ortho-Phosphat
nrow(phch_sam[phch_sam$name=="o-Phosphat-P", ]) # 1018
nrow(phch_sam[phch_sam$name=="ortho-Phosphat", ]) ##PO4 3-  # 891
# Is that the same just with a different name? Can I then combine them? if yes --> Just rename one variable to the other

phch_sam <- phch_sam %>%
  filter(psm == 'TRUE' | name %in% c("Wassertemperatur", "pH-Wert (Feld)", "Elektrische LeitfÃ¤higkeit (25Â°C)", "SauerstoffsÃ¤ttigung", "gesamter organisch gebundener Kohlenstoff", "Gesamt-Stickstoff" , "o-Phosphat-P", "ortho-Phosphat" ))

# Rename all names
phch_sam$name[phch_sam$name=="Wassertemperatur"] <- "temperature"
phch_sam$name[phch_sam$name=="pH-Wert (Feld)"] <- "pH"
phch_sam$name[phch_sam$name=="Elektrische LeitfÃ¤higkeit (25Â°C)"] <- "conductivity"
phch_sam$name[phch_sam$name=="SauerstoffsÃ¤ttigung"] <- "oxygen"
phch_sam$name[phch_sam$name=="gesamter organisch gebundener Kohlenstoff"] <- "TOC"
phch_sam$name[phch_sam$name=="Gesamt-Stickstoff"] <- "tot_N"
phch_sam$name[phch_sam$name=="o-Phosphat-P"] <- "o_phosphat_p"
phch_sam$name[phch_sam$name=="ortho-Phosphat"] <- "ortho_phosphat"

```

### calculate TU from EC50
TU = log10(concentration of compound / EC50)
Calculate the sumTU and the maxTU per site and date.
```{r Tcalculate-TU, echo=TRUE, message=FALSE}
# Dataset with only psm data
phch_sam_y = phch_sam %>%
  filter(psm == TRUE) %>%
  mutate(TU = log10(value_fin) / ec50f_al4896_fin)
nrow(phch_sam_y) 

nrow(phch_sam_y[phch_sam_y$value_fin=="0", ])
# 24023
# Many pesticides have concentration of zero.
# The TU of theses measurements is therefore -infinity and has to be removed.

# remove infinite values
phch_sam_y = phch_sam_y %>%
  filter(!is.infinite(TU)) 

# calculate sumTU, maxTU
phch_sam_y_TU = phch_sam_y %>%
  group_by(sample_id, site_id, date) %>%
  summarise(sumTU = sum(TU), maxTU = max(TU), total = n())
# Good dataset of sumTU and maxTU
# --> Needs to be included in phch_sam as variable in name and value column

#phch_sam_y_TU <- phch_sam_y_TU[ ,phch_sam_y_TU$name]
# column name must be sumTU and maxTU respectively
# column sumTU and max TU must be converted to value_fin
# then:
# phch_sam_bin <- bind_rows(phch_sam, phch_sam_y_TU)
phch_sam_y_maxTU <- phch_sam_y_TU[,-4]
phch_sam_y_sumTU <- phch_sam_y_TU[,-5]
phch_TU_bind <- bind_rows(phch_sam_y_maxTU, phch_sam_y_sumTU)

# create new columns "name" and "value_fin"
# Remove columns sumTU and maxTU and total
phch_TU_bind <- phch_TU_bind %>%
  mutate(name = if_else(is.na(maxTU), "sumTU", "maxTU")) %>%
  mutate(value_fin = if_else(is.na(maxTU), sumTU, maxTU)) %>%
  select(-c(sumTU, maxTU, total))

# Remove single herbicides
phch_sam <- phch_sam[!phch_sam$psm==TRUE, ]

# Bind table with phch_sam table
phch_sam <- bind_rows(phch_sam, phch_TU_bind)

# Year, month and day column need to be renewed since they do not exist for sumTU and maxTU
phch_sam$year <- format(phch_sam$date, '%Y')  # Create column for year
phch_sam$month <- format(phch_sam$date, '%m') # Create column for month
phch_sam$day <- format(phch_sam$date, '%j')   # Create column for day of the year


```

Agricultural data.
```{r landuse-to-name-column}
# Join landuse data with diatom dataset . Remove all landuse sites where diatoms haven't been sampled.
landuse = semi_join(landuse, dia_sam_cca, by = "site_id") # does not need to be joined by month since landuse is independent of date

# change column "atkis_perc" to "value_fin"
names(landuse) [names(landuse) =="atkis_perc"] <- "value_fin"

# create column "name" with the entry "agriculture" in all columns
landuse$name <- "agriculture"

# create column "month" with the entry "07" in all columns
landuse$month <- "07"

# make copy of landuse dataset
landuse_09 <- landuse

# change month from 07 to 09
landuse_09$month <- "09"

# Bind landuse and landuse_09
landuse <- bind_rows(landuse, landuse_09)

# Bind landuse table to phch_sam
phch_sam <- bind_rows(phch_sam, landuse)

# List of all environmental variables
phch_list <- phch_sam %>%
  distinct(name) %>%
  arrange(name)
phch_list
```


Save and read in final environmental dataset before casting to wide format
```{r}
# saveRDS(phch_sam, file.path('cache', 'phch_sam_final.rds'))
phch_sam <- readRDS(file.path('cache', 'phch_sam_final.rds'))

```


Join phch_sam on dia_sam_cca by site_id to exclude all samples that were not taken at a diatom sampling site.

Also join dia_sam_cca on phch_sam by site_id to exclude all diatom samples were no phys-chem parameters were taken. --> does not need to be performed
```{r}
#phch_sam <- semi_join(phch_sam, dia_sam_cca, by =c("site_id","month"))
```

How many negative values are in value_fin? 
```{r}
nrow(phch_sam[phch_sam$value_fin<0 ,]) # 1310
phch_sam[phch_sam$value_fin<0 ,] # Many maxTU (and sumTU?) values are below zero.
nrow(phch_sam[phch_sam$value_fin==0 ,]) # 260
```

How many zero values are in envi dataset?
```{r}
nrow(phch_sam[phch_sam$value_fin==0 ,]) # 260
head(phch_sam[phch_sam$value_fin==0 ,])
# Parameters were below detection limit if final value is zero.
```

Aggregate environmental data over all years for July and September. Then, transform/cast form long to wide format.
```{r cast-envi, echo=TRUE, message=FALSE}
phch_sam_aggr <- phch_sam %>% 
  group_by(month, name, site_id) %>%
  summarise(mean = mean(value_fin),
            perc95 = quantile(value_fin, 0.95, na.rm = TRUE),
            total = n()) %>%
  arrange(name)

# Store single months as seperate elements of a list
phch_sam_list <- split(phch_sam_aggr, phch_sam_aggr$month)

#cast_envi <- lapply(phch_sam_list, function(x) dcast(x, site_id ~ name, value.var="perc95", fill = 0))
cast_envi <- lapply(phch_sam_list, function(x) dcast(x, site_id ~ name, value.var="perc95", fill = NA))

# Take the first column and store it as a rowname, afterwards, delete the first column.
cast_envi  <- lapply(cast_envi ,
                     function(x) { rownames(x) <- x[,1];
                                   x[,1] <- NULL;
                                   x })

# Remove rows where the row sum is zero.
#cast_envi <- lapply(cast_envi ,
#       function(x) { x[rowSums(x) != 0,] })
# Do not use since it messes up table and does not apply to any row anyways

```

### state as variable
```{r state-as-variable}
# create loop/lapply function to shorten skript

# Create variable for state
phch_siteid_07 <- phch_sam %>%
  filter(month=="07") %>% 
  distinct(site_id, .keep_all = TRUE)

phch_siteid_09 <- phch_sam %>%
  filter(month=="09") %>% 
  distinct(site_id, .keep_all = TRUE)

# Dataset with only site_id and state as new variable
phch_sam_state_07 <- phch_siteid_07 %>%
  mutate(state = sub('_.*$','', phch_siteid_07$site_id)) %>%
  select(site_id, state)

phch_sam_state_09 <- phch_siteid_09 %>%
  mutate(state = sub('_.*$','', phch_siteid_09$site_id)) %>%
  select(site_id, state)
# mutate matches the pattern i.e. first occurence of _ to the end of the string and replace with ''

phch_sam_state_07$state <- as.factor(phch_sam_state_07$state)
phch_sam_state_09$state <- as.factor(phch_sam_state_09$state)

# Set site_id as rownames
rownames(phch_sam_state_07) <- phch_sam_state_07$site_id
phch_sam_state_07$site_id <- NULL

rownames(phch_sam_state_09) <- phch_sam_state_09$site_id
phch_sam_state_09$site_id <- NULL

# Bind new column to table
cast_envi_1 <- cbind(cast_envi[[1]], NewColumn=phch_sam_state_07)
cast_envi_2 <- cbind(cast_envi[[2]], NewColumn=phch_sam_state_09)

# Combine both tables to recreate cast_envi list
cast_envi <- list(cast_envi_1, cast_envi_2)

# Rename list elements
names(cast_envi) <- c("07", "09")

# Which states are included in dataset?
unique(cast_envi[[1]][["state"]])
unique(cast_envi[[2]][["state"]])

#for (i in 1: length(cast_envi)) {
#  unique(cast_envi[[i]][["state"]])
#}
# Does not work, empty output

# Do binding to both list elements:
#cast_envi_trial <- for (i in 1:length(cast_envi)) {
#  cbind(cast_envi[[i]], phch_sam_state[[i]])
#}
# Does not work, empty output
```

How many missing values are in each variable?
```{r}
length(cast_envi[[1]][[1]]) # 122 rows in total

#lapply(cast_envi, function(a) sapply(a,is.na))
sapply(cast_envi[[1]], function(x) sum(is.na(x)))
sapply(cast_envi[[2]], function(x) sum(is.na(x)))
```
Most values are missing in agriculture and ortho_phosphate. As these are quite collinear anyways, I will remove them.

```{r remove-rare-variables}
cast_envi <- lapply(cast_envi, function(x) x[,-1])  # remove agriculture
cast_envi <- lapply(cast_envi, function(x) x[,-4]) # remove ortho_phosphate
```

load cca data
```{r load-cca-data}
cast_ge_cca <- readRDS(file.path('cache', 'dia_ge_final.rds'))
```

Remove all rows that contain NAs in envi dataset
And delete removed sites from diatom dataset
```{r rows-with-NAs}
lapply(cast_envi, nrow)
sum(complete.cases(cast_envi[["07"]])) # only 12 rows of 122 with no missing data
# when removing agriculture and ortho_phosphate prior to CCA, 65 rows are left

sum(complete.cases(cast_envi[["09"]])) # only 26 of 127 rows with no missing data
# when removing agriculture and ortho_phosphate prior to CCA, 87 rows are left

# Remove all rows that contain NAs
cast_envi <- lapply(cast_envi, function(x) {x[complete.cases(x), ]})

# Also delete rows of sites in cast_ge_cca dataset that do not exist anymore in cast_envi
site_envi_07 <- rownames(cast_envi[[1]])
site_envi_09 <- rownames(cast_envi[[2]])

cast_ge_cca[[1]] <- (cast_ge_cca[[1]][site_envi_07,])
cast_ge_cca[[2]] <- (cast_ge_cca[[2]][site_envi_09,])

#Make two seperate dataframes from lists
cast_ge_cca_07 <- cast_ge_cca[[1]]
cast_ge_cca_09 <- cast_ge_cca[[2]]

cast_envi_07 <- cast_envi[[1]]
cast_envi_09 <- cast_envi[[2]]
# just for better inspection

```


Load/save final datasets
```{r save-final-psm-datasets}
#saveRDS(cast_envi, file.path('cache', 'psm_final.rds'))
cast_envi <- readRDS(file.path('cache', 'psm_final.rds'))

```

###  Collinearity
I set r > 0.7 as a threshold for collinearity (Dorman et al. 2013)
```{r}
# Correlation between numeric and categorical variables
hetcor(cast_envi[["07"]], ML = FALSE, std.err = TRUE, bins=4, pd=TRUE)
hetcor(cast_envi[["09"]], ML = FALSE, std.err = TRUE, bins=4, pd=TRUE)
# Calculation of correlation with state variable does not work anymore for september dataset
```
July: no highly correlated variables (with r > 0.7)
September: sumTU and maxTU highly correlated (r = 1)

sumTU was removed from the September dataset.
```{r remove-collinear-variables}
cast_envi[[2]][["sumTU"]] <- NULL
```

### CCA with all variables 
```{r cca}
## July
names(cast_envi[["07"]])

dia_cca_07 <- cca(cast_ge_cca[["07"]] ~  conductivity + maxTU + o_phosphat_p  + oxygen + pH + sumTU + temperature + TOC + tot_N + state, cast_envi[["07"]], na.action=na.omit)
dia_cca_07
# na.exclude --> probably  the number of predictor variables (constraints) is higher than the number of remaining observations. 
# na.omit --> works but 110 deleted observations and 3 deleted species

# Plot
windows()
plot_cca_07 <- plot(dia_cca_07, main = "CCA July")
savePlot(filename="figures/plot_cca_07", type="png")  # window has to be open in order to save

## September
names(cast_envi[["09"]])
dia_cca_09 <- cca(cast_ge_cca[["09"]] ~ conductivity + maxTU + o_phosphat_p + + oxygen + pH + sumTU + temperature + TOC + tot_N + state, cast_envi[["09"]], na.action=na.omit)
dia_cca_09

# Plot
plot_cca_09 <- plot(dia_cca_09, main = "CCA September")
savePlot(filename="figures/plot_cca_09", type="png")
dev.off()


cca_list <- list(dia_cca_07, dia_cca_09)

#the arrow points to the direction
#of the gradient, and its length indicates the strength of the variable

# Combine both months with for loop
# Does not work yet, no output...

#for (i in 1:length(cast_ge_cca)) {
#  cca(cast_ge_cca[[i]] ~ agriculture + conductivity + maxTU + o_phosphat_p + ortho_phosphat + oxygen + pH #+ sumTU + temperature + TOC + tot_N, cast_envi[[i]])
#}
```
The (unadjusted ???)explained (i.e. constrained) inertia of the July CCA is 14.75 % and of the September CCA it is 13.49 %.

With state variable: explained intertia of July CCA is 18.53 % (17.46 ??) and of the September CCA it s 15.74 %.

### VIF
```{r vif}
lapply(cca_list, function(x) vif.cca(x))
#lapply(cca_list_pars, function(x) vif.cca(x))
# not meaningful for categorical variables
```
VIF = 1 (Not correlated)
1 < VIF < 5 (Moderately correlated)
VIF >=5 (Highly correlated)


State variable has high VIFs -> method not appropriate for categorical variables 

Calculation of Pearson product-moment correlations between numeric variables and polyserial correlations between numeric and ordinal variables. --> High correlation between sumTU and maxTU in September. State variable has no high correlation with any other variable in both months.

For July, sumTU and maxTU both remain in the dataset and further variable selection will be based on forward selection. For September, only maxTU will remain in the dataset.According to (@Schafer.2013), there is not a great difference between the results of sumTU and maxTU, but in agricultural regions, the toxic effects are mainly driven by a single compound and therefor, maxTU will remain in the dataset although it seems like in this dataset, maxTU and sumTU are so highly correlated, the selection of either one of the variables would not make a big difference.

## Permutation tests in CCA, forwards selection and parsimonious CCA 
pp. 205 Numerical Ecology with R

Test for significance of CCA results by permutations
```{r permutation-test-of-cca-results}
# Permutation test of the overall analysis
lapply(cca_list, function(x) {anova(x, step = 1000)})

# Permutation test of each axis
lapply(cca_list, function(x) {anova(x, by="axis", step = 1000)})   # does not work when rows with NAs are not excluded in dataset.
```
The permutation test of the overall analysis indicates a significant model for the month July (p = 0.019) and a very significant model for the month September (p = 0.01).

The permutation test for each axis indicates a significant first axis (p = 0.024) for July. For the CCA for September, also only the first axis was significant (p = 0.019).

--> Exact values will change every time because different steps wil be performed, model is compared to different random models.


---- With reduced dataset, na.omit: ----
July: p = 0.079 --> no significant model
September: p = 0.001

significance of single axes:
July: No axis significant
September: First two axes significant

### Forward selection of variables
```{r forward-selection}
for (i in 1:length(cast_ge_cca)) {
  ordistep(cca(cast_ge_cca[[i]]~1, data = cast_envi[[i]]), scope = formula(cca_list[[i]]), direction = "forward", pstep = 1000)
}
```

July: cast_ge_cca[[i]] ~ pH + o_phosphat_p + conductivity  
is the most parsimonious model.

September: cast_ge_cca[[i]] ~ pH + tot_N + temperature + conductivity

```{r parsimonious-cca}
# July
dia_cca_pars_07 <- cca(cast_ge_cca[["07"]] ~ pH + o_phosphat_p + conductivity , cast_envi[["07"]])
dia_cca_pars_07

# September
dia_cca_pars_09 <- cca(cast_ge_cca[["09"]] ~ pH + tot_N + temperature + conductivity, cast_envi[["09"]])
dia_cca_pars_09

# Bind both CCAs to one list
cca_list_pars <- list (dia_cca_pars_07, dia_cca_pars_09)

# Summary of both CCAs
lapply(cca_list_pars, function(x) summary(x))
# Last element: Find out position of state variables in plot to known which x belongs to which state.

# Permutation test of the overall analysis
lapply(cca_list_pars, function(x) {anova(x, step = 1000)})

# Permutation test of each axis
lapply(cca_list_pars, function(x) {anova(x, by="axis", step = 1000)})
```
The explained (i.e. constrained) inertia of the July CCA was 18.53 % and of the September CCA it was 16.34 %. The explained inertia of the parsimonious CCAs was 6.8 % for July and 6.8 % for Septmeber.This drop is compensated by a clearer model with two significant canonical axes instead of one for both months.

The parsimonious CCA for July and September were both highly significant (p = 0.001)
The permutation test for each axis indicated that both axes of the July CCA were significant (p = 0.002 and 0.003). The permutation test for the September CCA indicates that the first 2 axes were significant ( p = 0.001 and 0.007). 

# Has to be rerfined for it to work!
```{r plot-labels}
# Biplots with species names
dianame_long_cca <- lapply(cast_ge_cca, function(x) colnames(x))

# dianame_m_ge <- lapply(cast_months_ge, function(x) make.cepnames(names(x)))
stems_ge_cca <- lapply(cast_ge_cca, colSums)

for (i in 1:length(dianame_long_cca)) {
  plot(cca_list_pars[[i]]) #red crosses = species, dots = sites
  orditorp(cca_list_pars[[i]], dis="sp", lab=dianame_long_cca[[i]], priority=stems_ge_cca[[i]],
           pcol="red", pch="+")
}

```


```{r plot-parsimonious-CCA}
windows()
plot_cca_pars_07 <-plot(dia_cca_pars_07, main = "parsimonious CCA July")
#identify(plot_cca_pars_07, what="species")  # manually assign which species should be shown
#identify(plot_cca_pars_07, what="sites")    # sites
savePlot(filename="figures/plot_cca_pars_07", type="png")

plot_cca_pars_09 <-plot(dia_cca_pars_09, main = "parsimonious CCA September")
identify(plot_cca_pars_09, what="species")  # manually assign which species should be shown
#identify(plot_cca_pars_09, what="sites")    # sites
savePlot(filename="figures/plot_cca_pars_09", type="png")
# [1] 14 21 34 38 41 points of species that are names in triplot
# dev.off() # R session terminates when using this command. Do it manually instead.
```

### Data inspection
Range of environmental parameters
```{r range-envi}
# in a nested loop
lapply(cast_envi, function(a) sapply(a[sapply(a,is.numeric)],range))

```

```{r}
# make two seperate dataframes from list
cast_envi_07 <- cast_envi[[1]]
cast_envi_09 <- cast_envi[[2]]

```


